# FutureProg Language Guide for AI Agents

> **Status:** In progress — "Purpose and Scope" is fully drafted while the remaining sections still list their execution tasks.

## Table of Contents
- [Purpose and Scope](#purpose-and-scope)
- [How FutureProg Fits Into FutureMUD](#how-futureprog-fits-into-futuremud)
  - [Engine integration points](#engine-integration-points)
  - [Lifecycle from authoring to execution](#lifecycle-from-authoring-to-execution)
  - [Builder touchpoints across the engine](#builder-touchpoints-across-the-engine)
- [Getting Started Quickly](#getting-started-quickly)
  - [Identifying Prog Contexts](#identifying-prog-contexts)
  - [Creating and Editing Progs](#creating-and-editing-progs)
  - [Running and Testing Progs](#running-and-testing-progs)
- [Language Fundamentals](#language-fundamentals)
  - [Execution Model](#execution-model)
  - [Script Structure and Syntax Basics](#script-structure-and-syntax-basics)
  - [Comments, Whitespace, and Formatting](#comments-whitespace-and-formatting)
- [Data Types and Literals](#data-types-and-literals)
  - [Primitive Types](#primitive-types)
  - [Composite and Collection Types](#composite-and-collection-types)
  - [Type Conversion Rules](#type-conversion-rules)
- [Variables and Scope](#variables-and-scope)
  - [Declaring and Assigning Variables](#declaring-and-assigning-variables)
  - [Lifetime and Visibility](#lifetime-and-visibility)
  - [Reserved Identifiers](#reserved-identifiers)
- [Expressions and Operators](#expressions-and-operators)
  - [Arithmetic, Comparison, and Logical Operators](#arithmetic-comparison-and-logical-operators)
  - [String Operations and Formatting](#string-operations-and-formatting)
  - [Collection Manipulation](#collection-manipulation)
- [Control Flow Statements](#control-flow-statements)
  - [`if` / `elseif` / `else`](#if--elseif--else)
  - [`switch` Statements](#switch-statements)
  - [Looping Constructs (`while`, `for`, `foreach`)](#looping-constructs-while-for-foreach)
  - [`break`, `continue`, and `return`](#break-continue-and-return)
  - [Exception and Error Handling](#exception-and-error-handling)
- [Functions](#functions)
  - [Built-in Function Catalog](#built-in-function-catalog)
  - [User-Defined Functions and Progs](#user-defined-functions-and-progs)
  - [Lambda Expressions and Inline Functions](#lambda-expressions-and-inline-functions)
  - [Performance Considerations](#performance-considerations)
- [Engine Objects and Context](#engine-objects-and-context)
  - [Understanding Prog Parameters](#understanding-prog-parameters)
  - [Working With Characters, Items, Rooms, and Other Entities](#working-with-characters-items-rooms-and-other-entities)
  - [Security, Permissions, and Trust Levels](#security-permissions-and-trust-levels)
- [Collections, Tables, and Data Queries](#collections-tables-and-data-queries)
  - [Iterating and Filtering Data](#iterating-and-filtering-data)
  - [Searching and Sorting Helpers](#searching-and-sorting-helpers)
  - [Interacting With Database-backed Data](#interacting-with-database-backed-data)
- [Events and Trigger Integration](#events-and-trigger-integration)
  - [Prog Types (Command, Script, Trigger, Output, etc.)](#prog-types-command-script-trigger-output-etc)
  - [Hooking Progs to Engine Events](#hooking-progs-to-engine-events)
  - [Scheduling and Delayed Execution](#scheduling-and-delayed-execution)
- [Input, Output, and Messaging](#input-output-and-messaging)
  - [Communicating With Players](#communicating-with-players)
  - [Formatting Output and Emotes](#formatting-output-and-emotes)
  - [Localization and Language Considerations](#localization-and-language-considerations)
- [State Management and Persistence](#state-management-and-persistence)
  - [Temporary vs Persistent State](#temporary-vs-persistent-state)
  - [Using Game Variables, Effects, and Tags](#using-game-variables-effects-and-tags)
  - [Interacting With External Systems](#interacting-with-external-systems)
- [Debugging and Diagnostics](#debugging-and-diagnostics)
  - [Tracing Execution](#tracing-execution)
  - [Inspecting Variables and State](#inspecting-variables-and-state)
  - [Handling and Reporting Errors](#handling-and-reporting-errors)
- [Testing and Validation Workflows](#testing-and-validation-workflows)
  - [Unit-style Testing Within FutureMUD](#unit-style-testing-within-futuremud)
  - [Regression Testing of Progs](#regression-testing-of-progs)
  - [Checklists Before Deployment](#checklists-before-deployment)
- [Best Practices and Patterns](#best-practices-and-patterns)
  - [Coding Standards for FutureProg](#coding-standards-for-futureprog)
  - [Common Idioms and Anti-patterns](#common-idioms-and-anti-patterns)
  - [Performance and Resource Management](#performance-and-resource-management)
- [Example Library and Case Studies](#example-library-and-case-studies)
  - [Annotated Examples From DatabaseSeeder](#annotated-examples-from-databaseseeder)
  - [Reusable Snippets by Category](#reusable-snippets-by-category)
  - [Patterns for Complex Systems](#patterns-for-complex-systems)
- [Reference Appendix](#reference-appendix)
  - [Statement Reference](#statement-reference)
  - [Function Reference by Category](#function-reference-by-category)
  - [Error Messages and Diagnostics Reference](#error-messages-and-diagnostics-reference)
  - [Glossary of Terms](#glossary-of-terms)
- [Additional Resources and Next Steps](#additional-resources-and-next-steps)

---

## Purpose and Scope

FutureProg is the scripting backbone that lets builders extend FutureMUD without recompiling the engine, and it appears in virtually every gameplay system from command hooks to AI routines. The purpose of this guide is to give an autonomous agent enough context to read the surrounding engine code, understand how FutureProg expects logic to be structured, and then deliver production-ready scripts that compile cleanly and behave responsibly in-game. The document is organised as a progressive manual: it starts with a mental model of how progs plug into the engine, walks through the syntax and runtime rules of the language, and then layers on domain-specific guidance, patterns, and reference material. You should be able to land on any feature request—"make a crafting recipe use new skill checks", "add messaging polish to an NPC script", or "expose economy data in a report"—and trace the relevant FutureProg hooks, author the code, and validate it end-to-end using only the material here.

### Who this guide is for
- **Primary audience:** AI agents or highly technical builders who can edit the repository and run the engine locally. You are expected to act with the same discipline as an engine developer: write code that compiles, reason about side effects, and leave the database in a coherent state after your changes.
- **Secondary audience:** Human staffers who already know FutureMUD concepts but need a language reference or best-practices checklist while scripting.

### What you are expected to know already
To work effectively with FutureProg you should arrive with the following background knowledge:

1. **General programming literacy.** You should be comfortable with typed languages, control flow, boolean logic, and working within REPL- or command-driven tooling. FutureProg is strongly typed and compiled ahead of execution, so thinking in terms of static analysis and runtime side effects is essential.
2. **FutureMUD world concepts.** Understand what characters, game items, rooms, zones, and perceivables are, and how they relate to each other. Many functions operate on these entities and will make little sense without the broader engine vocabulary.
3. **Builder command workflow.** You need to know how to log into a FutureMUD instance with builder permissions, use commands like `prog list`, `prog edit`, and `prog execute`, and navigate related modules such as `hook` and `events`. Later sections assume you can fetch help text via `prog help ...` and interpret the output.
4. **Repository navigation.** Expect to inspect C# sources under `MudSharpCore/FutureProg`, browse DatabaseSeeder examples that instantiate `FutureProg` objects, and review auxiliary tooling such as the Futuremud Configuration Tool. The guide references specific files and directories so you can cross-check behaviours directly in code.

If any of the above feels unfamiliar, use the resources linked in the global `AGENTS.md` and the quick-start section of this document before attempting to write or modify progs. This guide does not re-teach basic programming or repository hygiene; instead it focuses on FutureProg-specific semantics, integration points, and patterns that let you produce safe, efficient, and maintainable scripts.

## How FutureProg Fits Into FutureMUD

### Engine integration points
FutureMUD brings the variable register online before loading any progs so that register metadata is available during compilation, then hydrates every prog from the database, compiles them, and only afterwards loads dependent systems such as hooks, channels, AIs, crafts, legal frameworks, and chargen pipelines.【F:MudSharpCore/Framework/FuturemudLoaders.cs†L224-L347】【F:MudSharpCore/Framework/FuturemudLoaders.cs†L2688-L2717】 The variable register itself reads type definitions, default values, and saved entries from Entity Framework models, giving FutureProg code a typed bridge to persistent game state while tracking changes that must be written back.【F:MudSharpCore/FutureProg/VariableRegister.cs†L29-L200】 Loaded scripts live in the global `IFuturemud.FutureProgs` collection, and new or cloned progs are added to that collection at runtime so every subsystem resolves the same compiled instance.【F:MudSharpCore/Framework/FuturemudVariables.cs†L394-L408】【F:MudSharpCore/Framework/Futuremud.cs†L1331-L1348】 Each `FutureProg` tokenises statements, enforces required return paths, and records compile errors, while execution builds a typed variable space, guards against runaway recursion, caches static results, and reports failures through the Discord notifier for staff to investigate.【F:MudSharpCore/FutureProg/FutureProg.cs†L210-L293】【F:MudSharpCore/FutureProg/FutureProg.cs†L529-L617】 Hooks and command interceptors wrap that runtime: `FutureProgHook` replays attached scripts when engine events fire, whereas `CommandHookFutureProg` feeds command parameters into a text-returning prog so builders can synthesise commands dynamically.【F:MudSharpCore/Events/Hooks/FutureProgHook.cs†L12-L103】【F:MudSharpCore/Events/Hooks/CommandHookFutureProg.cs†L10-L61】

### Lifecycle from authoring to execution
Builders orchestrate progs through the comprehensive `prog` command set, whose built-in help covers listing scripts, editing metadata, compiling, executing, and pulling reference material for statements, types, and functions.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L50-L138】 Running `prog edit` attaches an editing effect to the selected script, while `prog edit new` and `prog edit newevent` create database records, wrap them as `FutureProg` instances, compile them once, add them to the shared catalogue, and drop the builder into an editor ready to flesh out the body text.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L1422-L1644】 Text changes, parameter management, and metadata updates flow through dedicated subcommands that mark the prog dirty, update the in-memory object, and immediately trigger a recompile so authors see any compiler feedback before moving on.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L1356-L1404】【F:MudSharpCore/Commands/Modules/ProgModule.cs†L1680-L1870】 Builders can force a full recompilation pass with `prog compile`, and when a prog is marked changed its `Save` routine writes the latest text, parameters, and settings back to the EF models.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L1648-L1662】【F:MudSharpCore/FutureProg/FutureProg.cs†L660-L667】 When attaching scripts elsewhere, helpers such as `ProgLookupFromBuilderInput` enforce return types, parameter signatures, and visibility rules before handing back a callable reference, keeping incompatible progs from leaking into other systems.【F:MudSharpCore/FutureProg/ProgLookupFromBuilderInput.cs†L55-L197】 Builders can smoke-test logic with `prog execute`, which resolves typed parameters, runs the compiled body, and reports both the result and execution time; during that call the runtime populates the variable space, honours recursion limits, and forwards exceptions or statement errors to Discord for triage.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L715-L769】【F:MudSharpCore/FutureProg/FutureProg.cs†L529-L617】

### Builder touchpoints across the engine
Because so many systems consult FutureProg logic, the boot sequence ensures progs are compiled before modules such as hooks, AIs, crafts, economy, legal code, and chargen load, guaranteeing those subsystems can immediately resolve their configured scripts.【F:MudSharpCore/Framework/FuturemudLoaders.cs†L224-L347】 The installer seeds core permission progs—like `IsAdmin` and `CanCreateClan`—which show how registers, static booleans, and builder-toggled flags govern who can perform sensitive actions.【F:DatabaseSeeder/Seeders/CoreDataSeeder.cs†L2623-L2888】 NPC behaviours lean heavily on FutureProg as well; the door guard suite decides who to admit, how long to wait, and which `force` commands to issue, demonstrating real-time control over characters, exits, and messaging.【F:DatabaseSeeder/Seeders/UsefulSeeder.cs†L6356-L6526】 Character subsystems fetch named progs for stamina, blood volume, liver function, and alias limits from static configuration, so tuning gameplay often means editing the referenced scripts rather than rebuilding the engine.【F:MudSharpCore/Character/Character.cs†L1303-L1327】 Finally, hook definitions bind progs to engine events and command interceptors, letting builders add scripted reactions or generate follow-up commands without touching C# while still drawing from the shared `IFuturemud.FutureProgs` catalogue.【F:MudSharpCore/Events/Hooks/FutureProgHook.cs†L12-L103】【F:MudSharpCore/Events/Hooks/CommandHookFutureProg.cs†L10-L61】

## Getting Started Quickly

### Identifying Prog Contexts
FutureProg scripts appear in most builder-facing systems, so begin by matching your goal to the engine surface that executes the prog. The table below lists the contexts you will reach for most often and where to study working examples:

| Context | What it controls | Where to inspect |
| --- | --- | --- |
| **Reusable functions and helpers** | Generic progs that return values for other scripts or systems (e.g., permissions, math helpers). Seeds such as `AlwaysTrue`/`AlwaysFalse` demonstrate the minimalist pattern, and the runtime exposes them through the `FutureProgInvokerFunction` so any prog can call another by ID. | See `DatabaseSeeder/Seeders/CoreDataSeeder.cs` for the reusable boolean/number helpers that ship with a fresh game, and `MudSharpCore/FutureProg/Functions/FutureProgInvokerFunction.cs` for the interpreter wrapper that calls other progs. |
| **Event hooks and triggers** | Logic that fires when the engine raises an event (room entry, effect updates, scheduler payloads, etc.). Hooks may execute one or many attached progs and are configured through the `hook`/`events` builder tooling. | `MudSharpCore/Events/Hooks/FutureProgHook.cs` loads referenced progs, executes them when the hook’s event type is raised, and persists the link in the database definition. |
| **Command interceptors** | Text progs that return commands for the engine to run, enabling dynamic command synthesis or macro behaviour. | `MudSharpCore/Events/Hooks/CommandHookFutureProg.cs` resolves a text-returning prog and feeds its output back into the command pipeline whenever the hook triggers. |
| **Channels and output filters** | Booleans that gate who can hear/speak on a communication channel or customise presentation. These progs often appear in staff-controlled moderation features. | `MudSharpCore/Communication/Channel.cs` stores listener/speaker progs per channel and checks them before letting a character join or send. |
| **AI behaviours and automation** | Decision trees for NPC templates, scripted delays, and AI actions. Builders frequently embed these IDs into XML definitions to orchestrate behaviours. | The UsefulSeeder wires door-guard routines, delays, and reactions by inserting prog IDs into the generated AI definition, illustrating how behaviour packs are composed. |
| **Chargen, permissions, and gating** | Checks that approve/deny choices during character creation or other permission-sensitive flows. Typically boolean/number outputs consumed by higher-level systems. | Character creation seeds define age, height, and other eligibility logic through dedicated progs that are later referenced by chargen steps. |
| **Scheduled automation** | Background tasks that run on an in-game schedule without player input. | `MudSharpCore/FutureProg/ProgSchedule.cs` persists the schedule, registers listeners, and re-queues the prog after each execution. |

When you encounter an unfamiliar system, search for a property ending in `ProgId` or an XML field that contains prog IDs to discover how it consumes FutureProg logic, then explore the referenced progs with `prog show` or by locating their seeds.

### Creating and Editing Progs
The `prog` command set is the primary workflow for day-to-day authoring. Its help banner lists every subcommand, including ways to browse existing scripts, start editing sessions, create new progs, and pull reference material for language features. A typical session looks like this:

1. **Locate a starting point.** Use `prog list`, `prog categories`, and `prog show <prog>` to review existing scripts before you make changes.
2. **Open or scaffold a prog.** `prog edit <id|name>` attaches the builder editing effect to an existing script; `prog edit new <name>` creates a blank void-returning prog; and `prog edit newevent <event> <name>` seeds parameters from the event metadata so the builder lands in an editor with a correctly typed signature.
3. **Clone for experimentation.** `prog clone <source> [newName]` copies metadata, parameters, and body text so you can iterate without risking a production script.
4. **Adjust metadata.** While editing, `prog set` variants change the function name, category, subcategory, comments, return type, static flag, and parameter list; any unsupported option drops you back to the master help so you can confirm syntax. Parameter management commands refuse to run on “accepts any parameter” progs, prompting builders to toggle that flag first when necessary.
5. **Edit the body.** `prog set text` or `prog set append` launches the text editor, echoes the current signature, and recompiles immediately when you save so errors surface before you exit the session.

Builders who prefer a graphical workflow can open the Futuremud Configuration Tool. The `FutureProgViewer` control loads progs from the database, recompiles the selected script to show compiler feedback, colourises the body for review, and exposes buttons to add/remove progs or parameters before saving back through Entity Framework. Use `prog compile` in-game afterwards so the live runtime picks up any offline edits.

When seeding content in C#, follow the same steps programmatically: instantiate `FutureProg`, set its metadata, add `FutureProgsParameter` rows in index order, attach the object to the EF context, and save. The seeders in `CoreDataSeeder` and `UsefulSeeder` show both parameterless helpers and multi-parameter AI routines wired into other systems once the IDs are known.

### Running and Testing Progs
`prog execute <prog> [parameters]` is the fastest way to smoke-test logic in-game. The command resolves typed parameters (supporting quoted or parenthesised inputs for complex expressions), prints the arguments back to you, runs the prog, displays the typed return value, and reports how long execution took so you can spot expensive scripts. Pair this with `prog clone` to create throwaway copies for experimentation without disturbing production hooks.

Whenever you make sweeping changes or edit progs outside the MUD, run `prog compile` to force a full recompile. The engine will colourise the source again and highlight any progs that now fail to compile, keeping runtime state consistent.

Behind the scenes the runtime guards against common hazards. `ExecuteWithRecursionProtection` initialises a variable space for typed parameters, enforces a recursion depth limit, caches static progs, and reports assignment or statement failures through the Discord notifier so staff can react quickly. Those protections make it safe to iterate rapidly, but you should still review hook or schedule callers (see the contexts above) to ensure your test scripts are not wired into live automation before you execute them.

## Language Fundamentals

### Execution Model
FutureProg scripts are compiled ahead of execution. Calling `Compile()` clears any cached statements, splits `FunctionText` into individual lines, seeds the compile-time variable space from declared parameters (plus an implicit `return` slot for non-void progs), and iteratively asks `CompileNextStatement` to build statement objects. Compilation halts immediately on syntax errors, disallows top-level `break`/`continue`, and enforces the presence of a terminating `return` when the prog advertises a return type.【F:MudSharpCore/FutureProg/FutureProg.cs†L220-L293】

`CompileNextStatement` normalises each line, strips blank lines and full-line comments, dispatches to the first registered statement compiler whose regex matches, and falls back to treating a bare expression as a `FunctionStatement`. Each compiler returns a `CompileInfo` package that carries the compiled statement, any updated variable type bindings, and the remaining unparsed lines for the outer loop to process.【F:MudSharpCore/FutureProg/FutureProg.cs†L908-L938】【F:MudSharpCore/FutureProg/Compiler/CompileInfo.cs†L14-L103】 This mechanism lets higher-level statements such as loops hand back an updated variable map so later lines compile with awareness of declarations made inside the block.

At runtime, `Execute` (or `ExecuteWithRecursionProtection` when you expect mutual recursion) wraps incoming arguments in typed `IProgVariable` instances, inserts a default `return` variable when needed, and resets the recursion depth guard. The method then walks the compiled statement list inside `InternalExecute`, honouring each statement’s `StatementResult`: `Return` delivers the stored `return` value, `Error` is reported to staff via the Discord bridge, and successful completion for fully static progs caches the computed value for reuse.【F:MudSharpCore/FutureProg/FutureProg.cs†L529-L637】 Variable bindings live in a `VariableSpace`, and statements that introduce nested scopes (loops, conditionals, functions) clone that space via `LocalVariableSpace` so inner assignments can either shadow or write back to parent scopes as appropriate.【F:MudSharpCore/FutureProg/VariableSpace.cs†L6-L33】【F:MudSharpCore/FutureProg/LocalVariableSpace.cs†L5-L33】【F:MudSharpCore/FutureProg/Statements/WhileLoop.cs†L31-L190】

### Script Structure and Syntax Basics
Every prog record carries metadata that controls how the engine exposes it: `FunctionName`, `Category`, `Subcategory`, visibility (`Public`), the textual body, declared parameters with their `ProgVariableTypes`, return type, the `AcceptsAnyParameters` flag for flexible signatures, and the `StaticType` that governs caching semantics.【F:MudSharpCore/FutureProg/FutureProg.cs†L144-L185】 Updating `FunctionText` automatically triggers recolourisation and marks the prog as changed so the editor warns about unsaved work.【F:MudSharpCore/FutureProg/FutureProg.cs†L148-L159】

The body itself is organised as one statement per line. Structural statements (`if`, `while`, `for`, `foreach`, `switch`) are paired with explicit terminators like `end if` or `end while`; their compilers verify block syntax, ensure condition expressions return the right type, and return the nested statements plus any new variable declarations for downstream lines to respect.【F:MudSharpCore/FutureProg/Statements/WhileLoop.cs†L31-L190】 When no statement compiler matches a line, the parser interprets it as a function or method invocation, meaning you can place pure expressions on their own lines without additional keywords.【F:MudSharpCore/FutureProg/FutureProg.cs†L922-L938】 Because compilation refuses to finish non-void progs that lack a guaranteed `return`, aim to exit every branch explicitly, especially inside conditional blocks.【F:MudSharpCore/FutureProg/FutureProg.cs†L276-L288】 The in-engine statement help (e.g., the `while` registration) is a good template for the canonical syntax and typical indentation of each construct.【F:MudSharpCore/FutureProg/Statements/WhileLoop.cs†L124-L151】

In practice a minimal reusable prog might look like:

```prog
var total as number
total = @character.Attributes["strength"]
return total
```

### Comments, Whitespace, and Formatting
FutureProg recognises only full-line comments. After trimming leading whitespace, any line that begins with `--`, `//`, or a single quote is stripped out by the compiler and treated as commentary, so inline comments must be written on their own line above the statement they describe.【F:MudSharpCore/FutureProg/FutureProg.cs†L61-L77】【F:MudSharpCore/FutureProg/FutureProg.cs†L911-L920】 Empty or whitespace-only lines are also skipped during compilation, which keeps the parser simple while still letting you separate logical sections for readability.【F:MudSharpCore/FutureProg/FutureProg.cs†L225-L268】

The editor’s colouriser reflows the stored text, trimming each line and applying indentation based on statement depth before presenting it back to builders. It indents by two spaces per nesting level, adjusts depth whenever it sees `if`/`end if` style keywords, and keeps numbered gutters for reference; adhering to that indentation pattern in source control makes diffs predictable and matches what builders see in-game.【F:MudSharpCore/FutureProg/FutureProg.cs†L1188-L1248】 Because indentation is cosmetic to the parser, focus on clarity: group related statements with blank lines, favour one statement per line, and use the available comment styles to flag assumptions or guard conditions in complex blocks.

## Data Types and Literals

### Primitive Types
FutureProg’s scalar types are defined in the `ProgVariableTypes` enumeration. The core primitives you will use most often are `Text`, `Number`, `Boolean`, `DateTime`, and `TimeSpan`; each entry records the underlying .NET type that backs the prog variable and therefore the methods and comparisons that are legal for that value.【F:FutureMUDLibrary/FutureProg/IProgVariable.cs†L6-L120】 Dedicated wrapper classes expose those values and any dot-properties that FutureProg adds on top—for example, `BooleanVariable` returns a native `bool`, `NumberVariable` wraps a decimal, and the date/time wrappers surface `.year`, `.month`, `.day`, `.hour`, `.minute`, `.second`, `.days`, `.hours`, `.minutes`, `.seconds`, and `.milliseconds` properties for quick access in scripts.【F:FutureMUDLibrary/FutureProg/Variables/BooleanVariable.cs†L5-L36】【F:FutureMUDLibrary/FutureProg/Variables/NumberVariable.cs†L5-L47】【F:FutureMUDLibrary/FutureProg/Variables/DateTimeVariable.cs†L5-L82】【F:FutureMUDLibrary/FutureProg/Variables/TimeSpanVariable.cs†L5-L60】 The engine also defines `Void` for routines that return nothing and a `Literal` flag you will see attached to constant expressions during compilation.【F:FutureMUDLibrary/FutureProg/IProgVariable.cs†L7-L15】【F:MudSharpCore/FutureProg/Functions/ConstantFunction.cs†L5-L24】

Every declared variable starts life with a correctly typed neutral value. Plain scalars default to the C# zero-equivalent for their type, while complex values such as collections are constructed as empty containers, so your first statement can immediately add or index into them without extra guards.【F:FutureMUDLibrary/FutureProg/Variables/NullVariable.cs†L5-L67】【F:MudSharpCore/FutureProg/Statements/DeclareVariable.cs†L118-L150】

Literal syntax mirrors those types:

* **Numbers** are parsed as decimals, so either integer or floating-point text works (`42`, `3.5`, `-0.1`).【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L222-L230】【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L1179-L1182】
* **Booleans** accept the usual `true` / `false` spellings in any case.【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L220-L225】【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L1173-L1176】
* **Text** must be wrapped in double quotes; escape sequences such as `"` are respected when the compiler calls `ParseSpecialCharacters`.【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L232-L236】【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L1113-L1143】
* **Time spans** use the compact `XdYhZmWsUf` notation (any subset in order), so `2h30m` yields a two-and-a-half hour `TimeSpan`.【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L32-L34】【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L237-L244】
* **Dates** do not have a literal form; call helpers such as `ToDate("2024-01-01", "yyyy-MM-dd")` or the mud-calendar variants to obtain a typed `DateTime`/`MudDateTime` object.【F:MudSharpCore/FutureProg/Functions/DateTime/ToDateFunction.cs†L10-L102】

All variable references inside expressions are prefixed with `@` and must start with a letter; the parser rejects other characters to keep the grammar unambiguous.【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L1144-L1164】 A typical snippet from the seed data combines these rules by declaring a collection and switching on a character parameter: `var skills as trait collection`, `switch (@ch.Race)`, `return @skills`.【F:DatabaseSeeder/Seeders/ChargenSeeder.cs†L403-L418】

### Composite and Collection Types
FutureProg supports three container modifiers in addition to scalar types: `collection` (ordered list), `dictionary` (string-keyed map), and `collectiondictionary` (multi-value map). These modifiers are just flags in `ProgVariableTypes`, but the engine provides helper classes that expose rich behaviours such as `.count`, `.any`, `.keys`, or `.reverse` so you can treat them like idiomatic data structures.【F:FutureMUDLibrary/FutureProg/IProgVariable.cs†L62-L208】【F:FutureMUDLibrary/FutureProg/Variables/CollectionVariable.cs†L7-L90】【F:FutureMUDLibrary/FutureProg/Variables/DictionaryVariable.cs†L18-L109】【F:FutureMUDLibrary/FutureProg/Variables/CollectionDictionaryVariable.cs†L18-L115】 Declaring `var foo as text collection` immediately seeds `foo` with an empty `CollectionVariable`, `var cache as number dictionary` yields an empty `DictionaryVariable`, and the engine automatically provisions the correct typed elements when you declare the variants with `var`.【F:MudSharpCore/FutureProg/Statements/DeclareVariable.cs†L118-L144】 The same auto-initialisation happens for `var foo = ...` declarations, so the only difference is whether you provide the starting value yourself.【F:MudSharpCore/FutureProg/Statements/DeclareAndAssignVariable.cs†L29-L69】

You can access and mutate members with indexers: `@list[0]` retrieves the first element, `@dict[@key]` looks up by string or number, and assigning through the indexer writes back when the container type allows it. Collection dictionaries expose values but purposely reject assignment through the indexer so you manage the inner collections explicitly.【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L425-L519】 Containers also support LINQ-style extension helpers via the `.Where(...)`, `.Select(...)`, `.Sum(...)`, `.Any(...)`, and similar functions registered in the `CollectionExtension` subsystem, which execute the supplied lambda-like body against each element inside a temporary local scope.【F:MudSharpCore/FutureProg/Functions/CollectionExtensionFunction.cs†L7-L41】【F:MudSharpCore/FutureProg/Functions/CollectionExtension/WhereFunction.cs†L7-L66】 Combined with the seed patterns above—declare a collection, filter it, and return the result—you can express most data massaging tasks without dropping to C#.

### Type Conversion Rules
FutureProg enforces strong typing at compile time and runtime. Compatibility checks are centralised in `FutureProgVariableComparer`, which understands how to ignore the `Literal` flag, treat collections as their element type, and reject mismatched container kinds.【F:FutureMUDLibrary/FutureProg/IProgVariable.cs†L305-L360】 Statement compilers and runtime executors call that logic whenever you introduce or modify variables: `DeclareAndAssign` strips the literal bit from the RHS so the declared type is recorded accurately, `SetVariable` verifies the new value is assignable to the existing slot, and `return` statements insist that the expression matches the declared return type before the prog can compile or execute successfully.【F:MudSharpCore/FutureProg/Statements/DeclareAndAssignVariable.cs†L91-L106】【F:MudSharpCore/FutureProg/Statements/SetVariable.cs†L27-L111】【F:MudSharpCore/FutureProg/Statements/Return.cs†L30-L116】 When a mismatch does slip through, the engine produces descriptive errors such as “Tried to set a variable to an incorrect type” and halts the prog so builders see the problem immediately.【F:MudSharpCore/FutureProg/Statements/SetVariable.cs†L49-L55】

Arithmetic and concatenation rules add a few implicit conversions. Numeric expressions accept either other numbers or strings (which get concatenated) and text concatenation will coerce numbers, booleans, dates, and spans via `ToTextFunction` under the hood. Date and time arithmetic restricts operators so that you can only add spans to times and subtract compatible types, and attempting anything else yields compile-time errors.【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L555-L757】 If you need explicit casts, lean on the built-in helpers such as `tonumber(<text>)`, `totext(<number|boolean>)`, or `todate(<text>, <mask>)`, all of which return the strongly typed wrapper variables you expect.【F:MudSharpCore/FutureProg/Functions/BuiltIn/ToNumberFunction.cs†L10-L42】【F:MudSharpCore/FutureProg/Functions/BuiltIn/ToTextFunction.cs†L7-L33】【F:MudSharpCore/FutureProg/Functions/DateTime/ToDateFunction.cs†L10-L51】 Typed defaults still obey these rules—`NullVariable` manufactures the correct zero-value for the target type—so you can freely assign a new value later without tripping a conversion error.【F:FutureMUDLibrary/FutureProg/Variables/NullVariable.cs†L49-L67】 The common “assign, operate, return” pattern in the seed scripts (e.g., capturing a register value into `var ownerid as number` before comparing it) demonstrates how these conversions keep everything type-safe from declaration through to the final `return`.【F:DatabaseSeeder/Seeders/UsefulSeeder.cs†L6173-L6184】

## Variables and Scope

### Declaring and Assigning Variables
Variables are introduced with the `var` statement. Use `var name as type` when you want to declare the slot up front (optionally using `collection`, `dictionary`, or `collectiondictionary` modifiers), or `var name = expression` when you know the initial value immediately—both forms prevent you from reusing the reserved `return` identifier and store the name in lowercase so lookups are case-insensitive.【F:MudSharpCore/FutureProg/Statements/DeclareVariable.cs†L13-L115】【F:MudSharpCore/FutureProg/Statements/DeclareAndAssignVariable.cs†L14-L106】 Reassignment is a simple `name = expression` statement; the compiler confirms that the variable was declared and that the RHS is compatible before generating the assignment node.【F:MudSharpCore/FutureProg/Statements/SetVariable.cs†L27-L61】 To read a value inside expressions, prefix the variable with `@`—the tokenizer rejects anything other than letters, digits, and underscores so accidental typos surface as compile errors.【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L1144-L1164】 The seeding scripts follow exactly this pattern: declare a slot, populate it, and return it, e.g. `var ownerid as number`, `ownerid = ifnull(getregister(@ch, "npcownerid"),0)`, `return @ownerid == @tch.Id`.【F:DatabaseSeeder/Seeders/UsefulSeeder.cs†L6173-L6176】

### Lifetime and Visibility
Compilation begins with a variable space seeded from the prog’s named parameters (plus an implicit `return` slot for non-void routines), so those identifiers are always in scope regardless of where you reference them in the body.【F:MudSharpCore/FutureProg/FutureProg.cs†L232-L288】 At runtime the executor builds a fresh `VariableSpace`, populates it with strongly typed wrappers for each argument, and again inserts a `return` variable when needed, guaranteeing that every branch can write a result without null checks.【F:MudSharpCore/FutureProg/FutureProg.cs†L536-L555】 Nested statements clone that space using `LocalVariableSpace`, which proxies reads to the parent but lets you introduce temporary locals that disappear once the block exits. The standard control-flow statements (`if`/`elseif`/`else`, `while`, `for`, and `foreach`) all allocate a new local scope for their bodies while still pushing assignments to existing outer variables back up to the parent, so you can safely reuse loop counters or accumulate totals outside the loop.【F:MudSharpCore/FutureProg/LocalVariableSpace.cs†L5-L35】【F:MudSharpCore/FutureProg/Statements/IfBlock.cs†L332-L405】【F:MudSharpCore/FutureProg/Statements/WhileLoop.cs†L154-L191】【F:MudSharpCore/FutureProg/Statements/ForLoop.cs†L163-L206】【F:MudSharpCore/FutureProg/Statements/ForEachLoop.cs†L174-L212】 For data that must persist beyond a single execution, use the `setregister` statement. It requires a reference-typed target, a text key that names the register, and a value whose type matches the register definition; the call is forwarded to the `VariableRegister`, which validates the schema before saving the new value to the database.【F:MudSharpCore/FutureProg/Statements/SetRegister.cs†L22-L167】【F:MudSharpCore/FutureProg/VariableRegister.cs†L945-L994】 Builders frequently combine local scope and registers—for instance, `OnCreateClan` sets `setregister @ch "hascreatedaclan" true` so later progs can read that persistent flag.【F:DatabaseSeeder/Seeders/CoreDataSeeder.cs†L2898-L2908】

### Reserved Identifiers
Because the compiler pattern-matches on keywords, avoid using statement names or structural terminators as variable names. `return` is hard-reserved—the declaration statements throw an error if you attempt to reuse it—and block keywords such as `if`, `elseif`, `else`, `switch`, `case`, `default`, `for`, `foreach`, `while`, `end if`, `end while`, `end for`, and `end switch` are consumed by the parser to manage indentation and scope.【F:MudSharpCore/FutureProg/Statements/DeclareVariable.cs†L31-L36】【F:MudSharpCore/FutureProg/Statements/DeclareAndAssignVariable.cs†L78-L84】【F:MudSharpCore/FutureProg/FutureProg.cs†L61-L74】【F:MudSharpCore/FutureProg/Statements/IfBlock.cs†L13-L24】【F:MudSharpCore/FutureProg/Statements/Switch.cs†L13-L23】【F:MudSharpCore/FutureProg/Statements/WhileLoop.cs†L14-L18】【F:MudSharpCore/FutureProg/Statements/ForLoop.cs†L14-L18】【F:MudSharpCore/FutureProg/Statements/ForEachLoop.cs†L14-L16】 Loop control statements (`break`, `continue`) and infrastructure helpers like `setregister` and `return` likewise have dedicated compilers and help entries, so treat them as reserved words even if the parser would technically allow you to create a variable with the same spelling in a different case.【F:MudSharpCore/FutureProg/Statements/Break.cs†L12-L51】【F:MudSharpCore/FutureProg/Statements/Continue.cs†L12-L51】【F:MudSharpCore/FutureProg/Statements/SetRegister.cs†L11-L139】【F:MudSharpCore/FutureProg/Statements/Return.cs†L13-L116】 Using the canonical keywords keeps the colouriser aligned with the in-game editor and ensures future syntax extensions do not collide with user-defined identifiers.

## Expressions and Operators

FutureProg expressions are compiled by `FunctionHelper`, which walks each line in stages: boolean combiners (`and`, `or`), comparison operators, arithmetic, indexers, dot-references, and finally explicit function calls.【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L265-L860】 Because the parser splits on the first top-level operator it encounters within a stage, arithmetic symbols share the same precedence; use parentheses whenever you need to force an order of evaluation such as ensuring multiplication happens before addition.【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L520-L768】【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L1040-L1073】

### Arithmetic, Comparison, and Logical Operators

* **Numeric math.** Numbers support `+`, `-`, `*`, `/`, `%`, and `^`. The compiler insists that both sides resolve to numbers, but a `+` with a number on the left and text on the right yields a `StringConcatenationFunction`, letting you append numeric values directly into prose.【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L555-L592】 Dedicated classes such as `AdditionFunction`, `SubtractionFunction`, and `MultiplicationFunction` implement the actual arithmetic.【F:MudSharpCore/FutureProg/Functions/Mathematical/AdditionFunction.cs†L5-L27】【F:MudSharpCore/FutureProg/Functions/Mathematical/SubtractionFunction.cs†L5-L23】【F:MudSharpCore/FutureProg/Functions/Mathematical/MultiplicationFunction.cs†L5-L23】 Time-aware types have custom rules: `DateTime`/`MudDateTime` values accept `+`/`-` with `TimeSpan`, and subtraction between two dates produces a span difference, while raw `TimeSpan` values can add, subtract, multiply by a number, or divide by either a number or another span.【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L623-L768】 Unsupported combinations emit compile-time errors, so mismatched types surface early.
* **Text concatenation.** When text appears on the left-hand side of `+`, the compiler auto-coerces the right-hand operand into text (if it is number, boolean, `DateTime`, or `TimeSpan`) before delegating to `StringConcatenationFunction`. The runtime guards against null inputs and always returns a `TextVariable` representing the combined value.【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L596-L621】【F:MudSharpCore/FutureProg/Functions/Textual/StringConcatenationFunction.cs†L6-L34】【F:MudSharpCore/FutureProg/Functions/BuiltIn/ToTextFunction.cs†L8-L36】
* **Comparisons.** Equality operators (`==`, `!=`, `<>`) accept any two values of the same resolved type, coercing common primitives and performing case-insensitive comparisons for text. The negated forms compile to a `LogicalNotFunction` wrapped around `EqualityFunction`.【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L348-L402】【F:MudSharpCore/FutureProg/Functions/EqualityFunction.cs†L27-L58】【F:MudSharpCore/FutureProg/Functions/BuiltIn/LogicalNotFunction.cs†L8-L40】 `~=` checks whether the left text starts with the right text (case-insensitive), and relational operators (`<`, `<=`, `>`, `>=`) work for numbers, spans, and date types only.【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L351-L415】【F:MudSharpCore/FutureProg/Functions/Textual/StringStartsWithFunction.cs†L6-L28】 If the compiler cannot prove both sides share a compatible type, it rejects the expression.
* **Boolean logic.** The parser recognises `and` and `or`, compiling them into short-circuiting functions so the right-hand expression is skipped when the left already determines the result. There is no `xor` implementation—attempting to use it throws a compile error—and unary negation is available through the `not(<boolean>)` built-in.【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L269-L311】【F:MudSharpCore/FutureProg/Functions/Logical/AndFunction.cs†L18-L48】【F:MudSharpCore/FutureProg/Functions/Logical/OrFunction.cs†L18-L48】【F:MudSharpCore/FutureProg/Functions/BuiltIn/LogicalNotFunction.cs†L8-L37】

### String Operations and Formatting

* **Literal assembly.** Besides the `+` rules above, you can join an entire collection of text with the `concat(collection, joiner)` helper, which flattens the list using a specified separator.【F:MudSharpCore/FutureProg/Functions/Textual/ConcatStringCollectionFunction.cs†L27-L64】 `splittext(text, separator)` performs the inverse, returning a text collection split on the supplied token.【F:MudSharpCore/FutureProg/Functions/Textual/SplitText.cs†L22-L74】
* **Substrings and slices.** `substring(text, index)` returns the tail of a string from a zero-based offset, while the three-argument overload limits the length. Invalid indices yield empty strings, so you can safely slice without defensive guards.【F:MudSharpCore/FutureProg/Functions/Textual/Substring.cs†L20-L127】 Combine this with `splittext` to emulate more advanced parsing patterns.
* **Tabular formatting.** `texttable` and `bwtexttable` transform tab-delimited rows into colourised (or monochrome) ASCII tables. Headers can be passed as a text collection or a single tab-delimited string, and each row must provide the same number of columns. The third argument defines the target width so you can fit tables to the channel you are echoing into.【F:MudSharpCore/FutureProg/Functions/Textual/TextTableFunction.cs†L20-L148】 These helpers are ideal for status readouts or administrative summaries.
* **Type coercion.** When you need to format non-text primitives manually, call `totext(<value>)`. The function accepts booleans and numbers (additional overloads exist for other types) and returns the canonical string representation, matching what the concatenation logic would generate implicitly.【F:MudSharpCore/FutureProg/Functions/BuiltIn/ToTextFunction.cs†L8-L36】

### Collection Manipulation

* **Indexers.** Collections use numeric indices (`@items[0]`), dictionaries accept either numeric or text keys (`@stats["strength"]`), and collection dictionaries expose lookups but intentionally block assignment through the indexer so you manage the nested lists yourself.【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L425-L519】 The compiled indexers call dedicated runtime helpers such as `CollectionIndexFunction` and `DictionaryIndexFunction`, which validate bounds and return a null variable when the key is missing.【F:MudSharpCore/FutureProg/Functions/CollectionIndexFunction.cs†L1-L33】【F:MudSharpCore/FutureProg/Functions/DictionaryIndexFunction.cs†L1-L33】
* **Dot properties.** Every collection-like variable registers convenience accessors. Plain collections expose `.count`, `.any`, `.empty`, `.first`, `.last`, and `.reverse`, dictionaries add `.keys` and `.values`, and collection dictionaries provide `.longcount` (total values across all buckets). The getters materialise the appropriate `ProgVariable` subtype so you can chain further operations without manual casting.【F:FutureMUDLibrary/FutureProg/Variables/CollectionVariable.cs†L6-L90】【F:FutureMUDLibrary/FutureProg/Variables/DictionaryVariable.cs†L18-L109】【F:FutureMUDLibrary/FutureProg/Variables/CollectionDictionaryVariable.cs†L18-L115】
* **Extension functions.** Dot-referencing a collection followed by `FunctionName(var, expression)` invokes the collection extension subsystem. `CollectionExtensionFunction` maintains the registry and enforces both the element type and the inner function’s return type before handing off to implementations such as `.Where`, `.Select`, `.SelectMany`, `.First`, `.Find`, `.Any`, `.All`, `.Count`, `.Sum`, `.Average`, `.Min`, `.Max`, and `.StdDev`. Each helper clones a `LocalVariableSpace`, binds the loop variable (the name you supply as the first argument), and then executes the body against each element, returning either a filtered collection, an aggregated number, or a boolean summary.【F:MudSharpCore/FutureProg/Functions/CollectionExtensionFunction.cs†L7-L41】【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L807-L833】【F:MudSharpCore/FutureProg/Functions/CollectionExtension/WhereFunction.cs†L1-L55】【F:MudSharpCore/FutureProg/Functions/CollectionExtension/SelectFunction.cs†L1-L48】【F:MudSharpCore/FutureProg/Functions/CollectionExtension/SelectManyFunction.cs†L8-L58】【F:MudSharpCore/FutureProg/Functions/CollectionExtension/FirstFunction.cs†L6-L64】【F:MudSharpCore/FutureProg/Functions/CollectionExtension/FindFunction.cs†L6-L65】【F:MudSharpCore/FutureProg/Functions/CollectionExtension/AnyFunction.cs†L6-L60】【F:MudSharpCore/FutureProg/Functions/CollectionExtension/AllFunction.cs†L6-L60】【F:MudSharpCore/FutureProg/Functions/CollectionExtension/CountFunction.cs†L7-L64】【F:MudSharpCore/FutureProg/Functions/CollectionExtension/SumFunction.cs†L8-L48】【F:MudSharpCore/FutureProg/Functions/CollectionExtension/AverageFunction.cs†L8-L60】【F:MudSharpCore/FutureProg/Functions/CollectionExtension/MinFunction.cs†L8-L62】【F:MudSharpCore/FutureProg/Functions/CollectionExtension/MaxFunction.cs†L8-L62】【F:MudSharpCore/FutureProg/Functions/CollectionExtension/StdDevFunction.cs†L9-L63】 These functions mirror LINQ idioms, letting you express complex queries without leaving FutureProg.

## Control Flow Statements
FutureProg’s block statements follow a consistent pattern: each compiler validates syntax, clones the current `VariableSpace` so branch-local declarations do not leak, and each executor propagates `Break`, `Continue`, `Return`, or `Error` results back to the caller. The `end <keyword>` marker always terminates the current block, mirroring curly braces in other languages.【F:MudSharpCore/FutureProg/Statements/IfBlock.cs†L43-L182】【F:MudSharpCore/FutureProg/Statements/IfBlock.cs†L332-L415】

### `if` / `elseif` / `else`

`IfBlock` compiles the condition expression and requires it to resolve to a boolean. Each branch gets its own `LocalVariableSpace`, so you can declare temporary variables inside an `if` without polluting the outer scope. The compiler enforces ordering rules—`elseif` conditions must also return booleans and cannot appear after an `else`—and ensures every block is closed with `end if`. At runtime the engine evaluates the condition, executes the matching branch in its local scope, and returns as soon as a nested statement signals `return`, `break`, or `continue`.【F:MudSharpCore/FutureProg/Statements/IfBlock.cs†L43-L182】【F:MudSharpCore/FutureProg/Statements/IfBlock.cs†L332-L415】 Nested `if` statements behave the same way, so indentation and explicit `end if` markers are your primary tools for readability.

### `switch` Statements

The `switch` compiler first evaluates the controlling expression, then parses a sequence of `case(<value>)` sections and an optional trailing `default`. Every case expression must return the same type as the switch expression; otherwise compilation fails. Multiple cases can appear, and a `default` is optional but must be last. During execution the engine evaluates each case function in order until it finds one whose result equals the switch value, then runs that block in a fresh `LocalVariableSpace`. A `break` exits the switch, `continue` bubbles up to the surrounding loop, and `return` propagates immediately, so you have explicit control over flow without implicit fallthrough.【F:MudSharpCore/FutureProg/Statements/Switch.cs†L11-L178】【F:MudSharpCore/FutureProg/Statements/Switch.cs†L280-L330】 If no case matches, the default block (when present) executes; otherwise the statement does nothing.

### Looping Constructs (`while`, `for`, `foreach`)

* **`while` loops.** The condition must return a boolean. The executor re-evaluates the expression before each iteration, clones a local scope for the loop body, and halts automatically if more than 10 000 iterations occur without a break to prevent runaway scripts. `break` exits the loop, `continue` skips to the next evaluation, and `return` propagates upward.【F:MudSharpCore/FutureProg/Statements/WhileLoop.cs†L31-L190】 This makes `while` the go-to tool when you need open-ended iteration with explicit termination logic.
* **`for` loops.** The syntax `for (varName : <number>)` counts from 1 up to the supplied number (inclusive). The regex limits the counter expression to digits, so dynamic counts must be calculated beforehand and stored in a variable, but the compiler still treats the literal as a full expression and type-checks it. Each iteration seeds the specified loop variable with the current index inside a `LocalVariableSpace`, giving you a clean counter without manual bookkeeping.【F:MudSharpCore/FutureProg/Statements/ForLoop.cs†L14-L206】 Negative or zero counts skip the body entirely.
* **`foreach` loops.** `foreach (varName in <collection>)` iterates each element of a collection variable. The compiler confirms the expression returns a collection and binds the loop variable to the element type for the body’s duration. As with other loops, a new `LocalVariableSpace` is created per iteration and control statements (`break`, `continue`, `return`) behave consistently.【F:MudSharpCore/FutureProg/Statements/ForEachLoop.cs†L14-L211】 Use this when you need to walk game object collections (characters, items, rooms, etc.) without manual indexing.

All loop forms share the same result propagation rules, so you can break out of nested structures or return from a prog confidently knowing the runtime will stop executing further statements in the enclosing block.【F:MudSharpCore/FutureProg/Statements/WhileLoop.cs†L165-L187】【F:MudSharpCore/FutureProg/Statements/ForLoop.cs†L177-L204】【F:MudSharpCore/FutureProg/Statements/ForEachLoop.cs†L185-L207】

### `break`, `continue`, and `return`

`break` and `continue` compile only when the parser can prove they appear inside a loop or switch block, and at runtime they return the dedicated `StatementResult` that the surrounding construct interprets.【F:MudSharpCore/FutureProg/Statements/Break.cs†L12-L44】【F:MudSharpCore/FutureProg/FutureProg.cs†L252-L259】 Each looping statement clones the current variable space, runs its child statements, and then inspects the returned result: `break` stops the loop and falls through, `continue` skips to the next iteration, and any propagated `return` or `error` immediately unwinds to the caller.【F:MudSharpCore/FutureProg/Statements/WhileLoop.cs†L17-L47】【F:MudSharpCore/FutureProg/Statements/ForLoop.cs†L17-L51】【F:MudSharpCore/FutureProg/Statements/ForEachLoop.cs†L18-L50】【F:MudSharpCore/FutureProg/Statements/Switch.cs†L312-L331】

`return` optionally carries an expression. During compilation the statement verifies that the prog actually declares a return slot and that the expression’s type is compatible, surfacing a descriptive error when it is not.【F:MudSharpCore/FutureProg/Statements/Return.cs†L31-L55】 The compiler seeds a `return` variable whenever the prog’s signature is non-void and inserts the same slot into the runtime variable space before execution begins, so any `return` statement can safely assign the outgoing value.【F:MudSharpCore/FutureProg/FutureProg.cs†L232-L239】【F:MudSharpCore/FutureProg/FutureProg.cs†L551-L554】 When the statement executes it evaluates the inner function, writes the result back to that slot, and halts the prog by bubbling up a `StatementResult.Return`.【F:MudSharpCore/FutureProg/Statements/Return.cs†L88-L109】 Void progs can use a bare `return` to end execution early, while non-void progs must supply a value.

### Exception and Error Handling

FutureProg does not expose try/catch constructs; instead, both the compiler and executor short-circuit when a statement reports `StatementResult.Error` along with an explanatory `ErrorMessage`.【F:MudSharpCore/FutureProg/Statements/Statement.cs†L1-L10】 Statement compilers validate syntax and types before emitting nodes, for example rejecting stray `break`/`continue` tokens at the top level or mismatched switch cases, so many issues surface before the prog ever runs.【F:MudSharpCore/FutureProg/FutureProg.cs†L217-L260】【F:MudSharpCore/FutureProg/Statements/Switch.cs†L40-L178】 At runtime every loop, switch, and return statement checks child results, copies the failing statement’s message, and stops execution so problems propagate cleanly to the caller.【F:MudSharpCore/FutureProg/Statements/WhileLoop.cs†L32-L47】【F:MudSharpCore/FutureProg/Statements/Switch.cs†L312-L331】【F:MudSharpCore/FutureProg/Statements/Return.cs†L94-L105】

`FutureProg.Execute` wraps the entire statement list in guard rails: arguments are coerced inside try/catch blocks that log parameter assignment exceptions, the engine aborts recursion beyond 250 nested calls, and in release builds any uncaught exception is trapped and reported through the Discord error channel before returning null.【F:MudSharpCore/FutureProg/FutureProg.cs†L537-L563】【F:MudSharpCore/FutureProg/FutureProg.cs†L603-L618】 Individual statements and functions should therefore validate inputs and return booleans where appropriate; if they detect unrecoverable conditions, setting `ErrorMessage` and returning `StatementResult.Error` ensures the runtime stops safely without corrupting game state.

## Functions
### Built-in Function Catalog

The engine registers hundreds of built-ins and categorises them through `FunctionCompilerInformation`, which exposes parameter lists, help text, and display metadata surfaced by the in-game `prog help function` command.【F:MudSharpCore/FutureProg/Functions/FunctionCompilerInformation.cs†L21-L139】 Commonly used domains include:

* **Numeric helpers.** The `Mathematical` folder implements arithmetic operators and rounding utilities so you can add, subtract, multiply, divide, exponentiate, take modulus values, and normalise decimals without writing boilerplate.【F:MudSharpCore/FutureProg/Functions/Mathematical/AdditionFunction.cs†L5-L33】【F:MudSharpCore/FutureProg/Functions/Mathematical/Round.cs†L17-L98】
* **Logical comparators.** Short-circuiting `and`/`or` plus relational operators live under `Logical`, giving you boolean evaluation that automatically propagates operand errors.【F:MudSharpCore/FutureProg/Functions/Logical/AndFunction.cs†L5-L48】
* **Text processing.** `Textual` functions cover concatenation, splitting, formatting, and other string utilities that return strongly typed wrappers for further composition.【F:MudSharpCore/FutureProg/Functions/Textual/SplitText.cs†L45-L74】
* **Collections and dictionaries.** Collection extension helpers such as `.Where` filter or transform lists using inline conditions, while dictionary setters let you mutate keyed containers safely.【F:MudSharpCore/FutureProg/Functions/CollectionExtension/WhereFunction.cs†L7-L66】【F:MudSharpCore/FutureProg/Functions/Dictionaries/Set.cs†L25-L97】
* **Type conversion and metadata.** Built-ins like `tonumber`, `totext`, and related helpers centralise coercion logic and fall back to sensible defaults when conversions fail.【F:MudSharpCore/FutureProg/Functions/BuiltIn/ToNumberFunction.cs†L8-L50】
* **Messaging.** Echo helpers send emotes or fixed-format text to perceivers, validating parameters and accepting optional perceivable targets for pronoun substitution.【F:MudSharpCore/FutureProg/Functions/Echoes/SendFunction.cs†L14-L199】
* **Characters and social systems.** Character functions grant knowledge, merits, and other traits while guarding against null references so staff scripts can safely manipulate player data.【F:MudSharpCore/FutureProg/Functions/Characters/GiveKnowledgeFunction.cs†L12-L82】
* **Items and crafting.** Item helpers toggle lock states, liquid contents, morph timers, and other component-specific behaviours, returning booleans to signal success.【F:MudSharpCore/FutureProg/Functions/GameItem/SetLockedFunction.cs†L8-L82】
* **World building.** Location functions create cells, approve overlays, and inspect rooms, enabling automated construction workflows directly from progs.【F:MudSharpCore/FutureProg/Functions/Location/CreateCell.cs†L19-L171】
* **Economy and currency.** Currency utilities move coins between characters, rooms, and containers, optionally giving change, while market influence helpers schedule long-running economic effects.【F:MudSharpCore/FutureProg/Functions/Currency/TakeCurrencyFunction.cs†L200-L320】【F:MudSharpCore/FutureProg/Functions/Economy/BeginInfluence.cs†L19-L126】
* **Status effects and AI.** Effects modules add or remove effects such as invisibility, and AI helpers manage territories, tagging captured rooms for NPC behaviours.【F:MudSharpCore/FutureProg/Functions/Effects/AddInvisEffectFunction.cs†L15-L105】【F:MudSharpCore/FutureProg/Functions/ArtificialIntelligence/AddTerritoryFunction.cs†L13-L99】
* **Health and combat.** Health functions apply wounds, interpret dice expressions, and validate damage types so combat scripts can injure characters consistently.【F:MudSharpCore/FutureProg/Functions/Health/WoundFunction.cs†L20-L199】
* **Legal, infrastructure, and accounts.** Crime helpers check warrants, grid functions connect devices to power networks, chargen utilities grant account resources, and register calls expose persistent entity metadata.【F:MudSharpCore/FutureProg/Functions/Crime/IsWantedFunction.cs†L18-L92】【F:MudSharpCore/FutureProg/Functions/Grids/ConnectToGrid.cs†L19-L87】【F:MudSharpCore/FutureProg/Functions/Chargen/GiveResource.cs†L20-L123】【F:MudSharpCore/FutureProg/Functions/Register/GetRegisterFunction.cs†L7-L60】
* **Lore and environment.** Celestial lookups provide moon phases or other astronomical data for rooms and zones.【F:MudSharpCore/FutureProg/Functions/Celestials/MoonPhaseFunction.cs†L10-L61】
* **External integrations.** Discord and OpenAI functions let scripts post embed-style updates or queue GPT threads, bridging in-game logic with out-of-band services.【F:MudSharpCore/FutureProg/Functions/Discord/SendDiscordMessageFunction.cs†L11-L75】【F:MudSharpCore/FutureProg/Functions/OpenAI/GPTRequest.cs†L21-L160】

This list is not exhaustive; browsing the directories under `MudSharpCore/FutureProg/Functions` reveals additional domains such as crime, economy, clans, climate, outfits, and more. Use the category strings registered with each function to organise your own documentation or quick-reference tables.

### User-Defined Functions and Progs

Referencing another prog inside a script works exactly like calling a built-in. During parsing, `FunctionHelper` checks whether the token matches a compiled user-defined prog whose parameter types line up, and if it succeeds the compiler emits a `FutureProgInvokerFunction` node that executes your argument expressions before delegating to the target prog.【F:MudSharpCore/FutureProg/Functions/FunctionHelper.cs†L891-L916】【F:MudSharpCore/FutureProg/Functions/FutureProgInvokerFunction.cs†L6-L28】 `FutureProg.MatchesParameters` enforces arity and compatible types, so maintaining accurate parameter declarations (or toggling `AcceptsAnyParameters` when appropriate) is essential for reuse.【F:MudSharpCore/FutureProg/FutureProg.cs†L187-L207】【F:MudSharpCore/Commands/Modules/ProgModule.cs†L1920-L1938】

Builders typically expose shared routines by marking them public and giving them stable names. Support tooling such as `prog set returns` and `prog set static` validates return types, recompiles after changes, and resets cached values, keeping reusable progs consistent when their signature changes.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L1940-L1992】 When hooking scripts elsewhere in the engine, helpers like `ProgLookupFromBuilderInput` resolve IDs or names, verify visibility, confirm return types, and ensure at least one acceptable parameter signature matches before returning a callable handle—failed lookups automatically echo diagnostics back to the builder.【F:MudSharpCore/FutureProg/ProgLookupFromBuilderInput.cs†L11-L198】

### Lambda Expressions and Inline Functions

FutureProg does not implement general-purpose lambda expressions; the parser only recognises named functions (built-in or user-defined) plus the specialised collection-extension syntax. Those extension helpers—`.Where`, `.Select`, `.Any`, and their peers—accept an inline function body that is compiled with a temporary local variable, effectively giving you lambda-like behaviour scoped to the collection iteration.【F:MudSharpCore/FutureProg/Functions/CollectionExtension/WhereFunction.cs†L7-L66】【F:MudSharpCore/FutureProg/Functions/FunctionCompilerInformation.cs†L100-L139】 Outside of that pattern you must promote reusable logic into named progs and call them explicitly. Because the compiler enforces return types and parameter compatibility for these inline bodies as well, you get the same safety guarantees as a regular function call.

### Performance Considerations

Every function call executes each argument expression first, so design reusable progs with narrow signatures and avoid nesting expensive computations unnecessarily.【F:MudSharpCore/FutureProg/Functions/FutureProgInvokerFunction.cs†L18-L28】 The runtime also guards against unbounded work: `while` loops abort after 10,000 iterations, recursion beyond 250 nested invocations is terminated, and `prog set static` disables caching automatically when you change a prog’s return type.【F:MudSharpCore/FutureProg/Statements/WhileLoop.cs†L17-L40】【F:MudSharpCore/FutureProg/FutureProg.cs†L527-L563】【F:MudSharpCore/Commands/Modules/ProgModule.cs†L1940-L1992】 When you explicitly mark a prog as fully static, the executor caches the first non-null return value and skips evaluation thereafter, resetting the cache whenever you flip the static flag or modify the prog.【F:MudSharpCore/FutureProg/FutureProg.cs†L175-L184】【F:MudSharpCore/FutureProg/FutureProg.cs†L529-L634】【F:MudSharpCore/Commands/Modules/ProgModule.cs†L1974-L1992】 Use that optimisation only for pure functions whose results truly never change with input or game state.

## Engine Objects and Context

### Understanding Prog Parameters

Every prog records its signature in the `NamedParameters` list, which captures the ordered `(type, name)` tuples supplied when the prog is created or loaded from the database.【F:MudSharpCore/FutureProg/FutureProg.cs†L90-L118】【F:MudSharpCore/FutureProg/FutureProg.cs†L164-L207】 The runtime exposes helpers such as `MatchesParameters` so hooks and other callers can verify compatibility before execution, and `AcceptsAnyParameters` lets you intentionally drop strict checking when a prog only inspects arguments opportunistically.【F:MudSharpCore/FutureProg/FutureProg.cs†L173-L207】 When a prog runs, `Execute` builds a `VariableSpace`, converts each supplied object into the declared type, seeds an implicit `return` slot for non-void progs, and enforces recursion and exception guards so mis-typed arguments or runaway calls fail fast without corrupting state.【F:MudSharpCore/FutureProg/FutureProg.cs†L537-L618】 Builders manage signatures with `prog parameter add|remove|swap`, which validates uniqueness, enforces declared types, recompiles immediately, and respects the “any parameters” toggle that clears the list for open-ended call sites.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L1670-L1819】【F:MudSharpCore/Commands/Modules/ProgModule.cs†L1913-L1937】 For ad-hoc testing, `prog execute` performs the same coercions you would get from an in-engine hook: it parses command arguments, converts them with `GetArgument`, and prints both the resolved parameter list and the returned value so you can confirm the signature behaves as expected.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L715-L768】 Keeping the metadata accurate is essential because other subsystems—event hooks, DatabaseSeeder templates, or other progs invoking yours—rely entirely on those stored types and names to wire calls correctly.

### Working With Characters, Items, Rooms, and Other Entities

FutureProg surfaces every major engine concept through targeted function families. Character functions such as `giveknowledge` declare their expected arguments and help text through `FunctionCompilerInformation`, then validate the runtime objects before mutating player data, returning booleans so scripts can branch on success.【F:MudSharpCore/FutureProg/Functions/Characters/GiveKnowledgeFunction.cs†L12-L82】 Item helpers follow the same pattern: `setlocked` accepts an item plus flags, probes for `ILock`/`ILockable` components, and safely updates state while signalling whether a change occurred.【F:MudSharpCore/FutureProg/Functions/GameItem/SetLockedFunction.cs†L8-L80】 World-building utilities such as `createcell` expose construction workflows by accepting overlay packages, zones, and optional template rooms, refusing to run unless the revision state allows editing, and returning the new location handle for further scripting.【F:MudSharpCore/FutureProg/Functions/Location/CreateCell.cs†L25-L172】 Beyond explicit functions, property access is available through the dot-notation runtime: `VariableDotReferenceFunction` requests properties from the underlying `IProgVariable`, and each variable type implements `GetProperty` so you can retrieve nested data like `@ch.Location.Name` without bespoke helpers.【F:MudSharpCore/FutureProg/Functions/VariableDotReferenceFunction.cs†L1-L32】【F:FutureMUDLibrary/FutureProg/IProgVariable.cs†L362-L383】 Taken together, these conventions let you combine strongly typed arguments, guarded mutations, and dot properties to orchestrate complex behaviours across characters, items, rooms, zones, and any other perceivable entity exposed by the engine.

### Security, Permissions, and Trust Levels

The command surface that edits or wires progs is intentionally limited to staff accounts. The primary `prog` command requires at least Admin permission, while `hook`—which can attach arbitrary code to engine events—demands Senior Admin, preventing lower-level builders from installing unsafe automation without oversight.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L60-L139】【F:MudSharpCore/Commands/Modules/ProgModule.cs†L2320-L2395】 These thresholds map to the global account hierarchy defined in `PermissionLevel`, so game owners can reason about which roles are authorised to script or deploy automation.【F:FutureMUDLibrary/Accounts/IAccount.cs†L92-L136】 Even once compiled, progs obey visibility rules: many builder tools, such as clan configuration, refuse to reference non-`Public` progs unless the actor is an administrator, guarding sensitive logic from casual reuse.【F:MudSharpCore/Commands/Modules/ClanModule.cs†L5090-L5118】 Inside scripts, you can interrogate the caller’s authority with helpers like `isadmin`, which checks the linked account or character before allowing privileged behaviour.【F:MudSharpCore/FutureProg/Functions/BuiltIn/IsAdminFunction.cs†L9-L65】 Finally, the executor itself provides defence-in-depth—parameter conversion errors are trapped and logged, recursion is capped at 250 frames, and any runtime exception generates a Discord alert—so even trusted progs fail safely without leaving the game in an inconsistent state.【F:MudSharpCore/FutureProg/FutureProg.cs†L537-L618】 Together these controls let you delegate scripting tasks confidently while retaining clear lines about who may deploy logic and how that logic is monitored.

## Collections, Tables, and Data Queries

### Iterating and Filtering Data

Collection-extension functions provide LINQ-style workflows without leaving FutureProg. Functions such as `.Where`, `.Select`, and `.Count` compile an inline body that executes inside a `LocalVariableSpace`, letting you bind each element to a temporary variable, evaluate a predicate or projection, and return a new collection or aggregate with the filtered results.【F:MudSharpCore/FutureProg/Functions/CollectionExtension/WhereFunction.cs†L7-L66】【F:MudSharpCore/FutureProg/Functions/CollectionExtension/SelectFunction.cs†L7-L64】【F:MudSharpCore/FutureProg/Functions/CollectionExtension/CountFunction.cs†L7-L65】 Because these helpers work directly against the strongly typed `IProgVariable` wrappers, they automatically preserve element types and avoid manual casting; common patterns include slicing character lists, transforming them into text summaries, and counting matches before branching on the total.

### Searching and Sorting Helpers

When you need to locate specific elements, the extension library ships ready-made search utilities. `.First` and `.Find` both evaluate a boolean body across a collection, either returning the first matching element or its index (with null/–1 if nothing matches), while numeric reducers such as `.Max`, `.Min`, and `.Average` evaluate an inner expression for each element and compute the requested statistic for ranking or threshold checks.【F:MudSharpCore/FutureProg/Functions/CollectionExtension/FirstFunction.cs†L6-L65】【F:MudSharpCore/FutureProg/Functions/CollectionExtension/FindFunction.cs†L6-L66】【F:MudSharpCore/FutureProg/Functions/CollectionExtension/MaxFunction.cs†L6-L63】 For direct positional access, `CollectionIndexFunction` and `DictionaryIndexFunction` let you pull a specific slot or keyed entry once you have the identifier you need, falling back to null when the lookup fails so scripts can guard against missing data.【F:MudSharpCore/FutureProg/Functions/CollectionIndexFunction.cs†L10-L40】【F:MudSharpCore/FutureProg/Functions/DictionaryIndexFunction.cs†L10-L40】 Combining these primitives makes it straightforward to implement ordered scans, deduplication, or ranking logic entirely within FutureProg.

### Interacting With Persistent Data

FutureProg progs read and write long-lived data through the variable register. `getregister` determines the correct return type from the target’s declared schema and retrieves the stored value, while `setregister` first consults the register metadata to ensure the key exists and the value you supply matches the registered type before committing it to the database.【F:MudSharpCore/FutureProg/Functions/Register/GetRegisterFunction.cs†L7-L61】【F:MudSharpCore/FutureProg/Statements/SetRegister.cs†L30-L168】 The register infrastructure automatically manufactures sensible defaults—empty collections, dictionaries, or typed nulls—when no value has been stored yet, so progs can treat missing data predictably.【F:MudSharpCore/FutureProg/VariableRegister.cs†L759-L858】 Seeder examples such as the clan-creation workflow demonstrate the pattern in practice: one prog checks a player’s `hascreatedaclan` flag via `GetRegister`, and a paired hook sets the same register to `true` once the clan is created, giving later scripts a persistent signal to consult.【F:DatabaseSeeder/Seeders/CoreDataSeeder.cs†L2880-L2908】 You can extend the approach to other persistent constructs—effects, tags, or bespoke registers—knowing the compiler and runtime will enforce schema correctness every time the data is read or written.

## Events and Trigger Integration

### Prog Types (Command, Script, Trigger, Output, etc.)

FutureProg hooks are indexed by the `EventType` enumeration. Each entry carries an `EventInfo` attribute that describes what the trigger does, the human-readable parameter names, and the `ProgVariableTypes` signature that your prog must match. That metadata powers both the in-game `show event <name>` command and the compatibility checks that run when you attach a prog to a hook.【F:FutureMUDLibrary/Events/EventInfoAttribute.cs†L10-L21】【F:MudSharpCore/Commands/Modules/ShowModule.cs†L1980-L2023】 Use `show events` to page through the available triggers, then drill into an individual event to confirm parameter ordering before you compile your prog.【F:MudSharpCore/Commands/Modules/ShowModule.cs†L1980-L2023】

Common event families include:

| Event type | Parameter signature | Typical uses |
| --- | --- | --- |
| `CharacterGotItem` | character, item | Fire inventory logic when someone picks an object up, e.g., to award achievements or audit contraband.【F:FutureMUDLibrary/Events/EventTypeEnum.cs†L10-L44】 |
| `CharacterEnterCell` | character, location, exit | Run room-enter scripts such as greetings, trap checks, or encounter spawning as soon as the mover crosses the threshold.【F:FutureMUDLibrary/Events/EventTypeEnum.cs†L135-L175】 |
| `CharacterEnterCellWitness` | character, location, exit, perceivable | Notify onlookers or NPC guards whenever someone arrives so they can react in real time.【F:FutureMUDLibrary/Events/EventTypeEnum.cs†L141-L181】 |
| `CommandInput` | character, perceivable, text, text collection | Intercept arbitrary commands before parsing to build custom command filters, restrictions, or analytics around player input.【F:FutureMUDLibrary/Events/EventTypeEnum.cs†L221-L227】 |
| `SelfCommandInput` | character, text, text collection | Gate self-directed commands such as `score` or `wear` on extra checks without affecting ambient command hooks.【F:FutureMUDLibrary/Events/EventTypeEnum.cs†L229-L234】 |
| `CharacterSpeaks` | character, volume text, language, accent, message text | React to speech events for AI dialogue, auto-translation, or eavesdropping mechanics tied to specific languages and volumes.【F:FutureMUDLibrary/Events/EventTypeEnum.cs†L271-L308】 |
| `CharacterEntersGame` | character | Initialise state when a character loads into the world, such as refreshing effects or scheduling onboarding reminders.【F:FutureMUDLibrary/Events/EventTypeEnum.cs†L215-L219】 |

Treat the table as a starting point: the enumeration covers dozens of additional hooks for crafting, movement edge cases, combat, and environmental changes. Always align your prog’s declared parameters with the signature that the `EventInfo` metadata advertises so the compiler and hook installer will accept it.

### Hooking Progs to Engine Events

Hook objects bridge an `EventType` to one or more progs. Builders manage them via the `hook` command set: create a hook with a name, prog, and event, optionally assign a command string for command-input events, install it on rooms/items/characters, and curate default hooks that auto-install on new entities.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L2320-L2899】 During `hook prog` the engine loads the target event’s `EventInfo` data and refuses to proceed if the prog’s parameter list is incompatible, so mismatches are caught before runtime.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L2478-L2487】 Command-triggered hooks (`CommandInput` and `SelfCommandInput`) require the extra command token when you create or edit them, otherwise installation will reject the hook because those event types expect the command context.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L2330-L2336】【F:MudSharpCore/Commands/Modules/ProgModule.cs†L2598-L2634】 Once a hook is created you can `hook install <hook> <target>` to attach it to a perceivable, and `hook defaults` lets you register filter progs so new rooms, characters, or items automatically gain the hook when they qualify.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L2529-L2873】 Internally the `FutureProgHook` type simply iterates its attached progs when the event fires, executing each one with the raw parameter list from the event payload.【F:MudSharpCore/Events/Hooks/FutureProgHook.cs†L12-L78】 That means all your branching, gating, and persistence should happen inside the prog itself.

### Scheduling and Delayed Execution

For short delays inside a prog, use the `delay` statement. It takes a millisecond duration, a character to act as the command source, and the text to execute; the compiler enforces those types so you can only queue valid character commands. A delay of zero executes immediately, otherwise the engine applies a `DelayedAction` effect that runs the command after the specified wait.【F:MudSharpCore/FutureProg/Statements/Delay.cs†L15-L134】【F:MudSharpCore/FutureProg/Statements/Delay.cs†L180-L211】 When you need to call another prog later, `delayprog` schedules it through the global scheduler. Supply the delay followed by the target prog’s parameters; the compiler verifies a matching prog exists and the scheduler callback executes it after the timeout using the captured arguments.【F:MudSharpCore/FutureProg/Statements/DelayProg.cs†L14-L128】【F:MudSharpCore/FutureProg/Statements/DelayProg.cs†L170-L209】 For recurring jobs, the administrative `schedule` command persists a `ProgSchedule` record tied to a `RecurringInterval`. Only parameterless (or “accepts any parameters”) progs are eligible, and you can specify both the cadence (`every <x> hours|days|...`) and the initial in-character datetime. The resulting `ProgSchedule` tracks the next fire time and automatically re-enqueues itself after each execution.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L2968-L3088】【F:MudSharpCore/FutureProg/ProgSchedule.cs†L13-L85】 Use these tools together to mix immediate reactions, short-lived timers, and long-running world processes.

## Input, Output, and Messaging

### Communicating With Players

FutureProg’s preferred messaging layer is the family of `send` built-ins under `Functions/Echoes`. The base `send` variant targets a single perceiver, accepts up to eight additional perceivables for `$0`, `$1`, etc. token substitution, and returns `true` when it successfully delivered the emote so you can branch on failures (e.g., missing recipients).【F:MudSharpCore/FutureProg/Functions/Echoes/SendFunction.cs†L12-L121】 Range-specific helpers such as `sendloc`, `sendarea`, `sendzone`, `sendshard`, and their `...fixed` counterparts broadcast to a room, area, zone, or shard respectively, optionally taking a room layer argument and the same perceivable list for token expansion.【F:MudSharpCore/FutureProg/Functions/Echoes/SendLocationFunction.cs†L13-L158】【F:MudSharpCore/FutureProg/Functions/Echoes/SendAreaFunction.cs†L13-L112】 All of these functions construct `EmoteOutput`s, so they respect visibility, pronouns, and colour handling automatically. The legacy `send` statement still exists, but the help text explicitly notes that builders should prefer the function versions; it exposes range modifiers (`local`, `surrounds`, `zone`, `shard`, `all`) and flags like `hidden`, `no1st`, and `gods` for Wiz-only echoes if you are maintaining older scripts.【F:MudSharpCore/FutureProg/Statements/Send.cs†L18-L196】 Because the functions return booleans, you can guard expensive follow-up logic behind a quick success check instead of assuming the echo occurred.

### Formatting Output and Emotes

Emote markup drives most FutureProg output. Tokens such as `@`, `$0`, and `$?2|...||...` let you conjugate verbs, insert possessives, or conditionally include phrases so every recipient sees grammatically correct text; the global agent guide documents the full token set with examples you can mirror in your scripts.【F:AGENTS.md†L120-L184】 The standard `send` helpers construct `Emote` instances, while the `sendfixed` variants swap in `NoFormatEmote` so the text is displayed verbatim—handy for ASCII art or already-formatted blocks.【F:MudSharpCore/FutureProg/Functions/Echoes/SendFunction.cs†L55-L118】【F:MudSharpCore/PerceptionEngine/Parsers/Emote.cs†L247-L273】 For structured data, the `texttable` and `bwtexttable` built-ins assemble columnar tables from collections of text values, letting you produce readable scorecards or reports directly inside progs without manual spacing logic.【F:MudSharpCore/FutureProg/Functions/Textual/TextTableFunction.cs†L11-L96】 Combine these tools: build your message with Emote tokens, optionally render it into a table, and then send it through the appropriate range helper.

### Localization and Language Considerations

Language-aware echoes use specialised helpers that inject an `ILanguage` and `IAccent` into the generated emote. Functions like `sendlang`, `sendarealang`, `sendterrainlang`, `sendzonelang`, and `sendshardlang` accept the same perceiver lists as their base counterparts but wrap the output in a `FixedLanguageEmote`, ensuring the speech system routes the text through comprehension rules so only characters who speak the language (or have translation aids) receive the full message.【F:MudSharpCore/FutureProg/Functions/Echoes/SendLangFunction.cs†L12-L105】【F:MudSharpCore/FutureProg/Functions/Echoes/SendAreaLangFunction.cs†L13-L111】【F:MudSharpCore/PerceptionEngine/Parsers/Emote.cs†L247-L273】 Hook signatures for speech events (`CharacterSpeaks`, `CharacterSpeaksDirect`, etc.) already provide the volume, language, accent, and raw text so your progs can forward the message verbatim, redact it, or layer additional localisation logic on top.【F:FutureMUDLibrary/Events/EventTypeEnum.cs†L271-L308】 Remember that area- and zone-wide language sends apply `OutputFlags.IgnoreWatchers`, avoiding double-echoes for watcher effects while still respecting accent and language cues.【F:MudSharpCore/FutureProg/Functions/Echoes/SendAreaFunction.cs†L55-L91】 Use the language-capable helpers whenever you want to produce in-character speech so you do not bypass the engine’s translation and literacy mechanics.

## State Management and Persistence

### Temporary vs. persistent state
Every prog execution begins with a fresh variable space seeded from the declared parameters (plus an implicit `return` slot for non-void signatures), so locals exist only for the lifetime of that invocation.【F:MudSharpCore/FutureProg/FutureProg.cs†L217-L293】【F:MudSharpCore/FutureProg/FutureProg.cs†L536-L596】 The runtime stores those slots in a `VariableSpace`, while nested scopes clone that space with `LocalVariableSpace` so inner blocks can shadow identifiers yet still write back to their parent when appropriate.【F:MudSharpCore/FutureProg/VariableSpace.cs†L6-L33】【F:MudSharpCore/FutureProg/LocalVariableSpace.cs†L5-L35】 Use these transient variables for pure computation or for staging data before you commit it elsewhere.

Persistent data lives in the variable register, a database-backed catalogue keyed by reference types (characters, rooms, items, etc.). The register loads schema definitions, default values, and saved entries at boot, exposes typed getters, and flushes any pending changes when the world saves.【F:MudSharpCore/FutureProg/VariableRegister.cs†L49-L200】【F:MudSharpCore/FutureProg/VariableRegister.cs†L776-L856】【F:MudSharpCore/FutureProg/VariableRegister.cs†L936-L956】 Builders write to it with the `setregister` statement, which enforces a reference target, a literal variable name, and a value that matches the registered type, and they read through the `getregister` function that resolves the correct wrapper automatically.【F:MudSharpCore/FutureProg/Statements/SetRegister.cs†L13-L110】【F:MudSharpCore/FutureProg/Functions/Register/GetRegisterFunction.cs†L12-L60】 Seeder examples demonstrate the pattern: `CanCreateClan` checks a stored flag while `OnCreateClan` sets it, and NPC ownership scripts retrieve a persistent owner ID before comparing it to a command issuer.【F:DatabaseSeeder/Seeders/CoreDataSeeder.cs†L2875-L2919】【F:DatabaseSeeder/Seeders/UsefulSeeder.cs†L6171-L6184】 Reset helpers fall back to defaults, and the register’s `Save` routine serialises any touched slots back to EF models so the data survives restarts.【F:MudSharpCore/FutureProg/VariableRegister.cs†L149-L199】【F:MudSharpCore/FutureProg/VariableRegister.cs†L759-L815】 When deciding where to keep information, treat the register as long-term storage and rely on locals for ephemeral calculations.

### Working with engine effects, tags, and other stateful constructs
FutureProg exposes most effect systems directly. Functions such as `addhealingeffect` and `addinviseffect` instantiate concrete effect objects, queue them on a perceivable, and optionally gate application behind another prog so you can centralise eligibility checks.【F:MudSharpCore/FutureProg/Functions/Effects/AddHealingEffectFunction.cs†L12-L114】【F:MudSharpCore/FutureProg/Functions/Effects/AddInvisEffectFunction.cs†L45-L104】 Presentation helpers like `OverrideDesc` first remove any matching overrides before adding a new effect, letting you reapply descriptive layers without stacking stale state.【F:MudSharpCore/FutureProg/Functions/BuiltIn/OverrideDesc.cs†L202-L218】 Downstream scripts can then query active effects with `EffectsOfType`, as shown in AI territory management and legal status checks that filter by concrete effect classes or metadata.【F:MudSharpCore/FutureProg/Functions/ArtificialIntelligence/AddTerritoryFunction.cs†L42-L60】【F:MudSharpCore/FutureProg/Functions/Crime/OnBailFunction.cs†L64-L72】 Beyond effects, tagging utilities like `istagged` resolve tag names or IDs through the central tag registry and report whether a perceivable counts as that tag, giving builders a consistent way to branch on categorical data across characters, locations, and terrains.【F:MudSharpCore/FutureProg/Functions/BuiltIn/IsTaggedFunction.cs†L20-L139】

### Interfacing with other FutureMUD systems
Stateful subsystems expose curated entry points so progs can orchestrate them without touching C#. Infrastructure helpers cover hardware-style grids (`connecttogrid` binds an item interface to a grid instance) and economic influences (the `begininfluence` family creates scheduled market modifiers while `endinfluence` tears them down).【F:MudSharpCore/FutureProg/Functions/Grids/ConnectToGrid.cs†L25-L86】【F:MudSharpCore/FutureProg/Functions/Economy/BeginInfluence.cs†L24-L159】【F:MudSharpCore/FutureProg/Functions/Economy/EndInfluence.cs†L24-L77】 External integrations are reachable from the same scripts: `senddiscord` pushes formatted embeds to configured channels, and `gptrequest` queues an OpenAI thread call, then hands the response back to a follow-up prog so you can persist or act on the result immediately.【F:MudSharpCore/FutureProg/Functions/Discord/SendDiscordMessageFunction.cs†L27-L74】【F:MudSharpCore/FutureProg/Functions/OpenAI/GPTRequest.cs†L27-L158】 Use these APIs alongside the register to coordinate world systems, schedule cross-cutting workflows, or surface diagnostics in out-of-band services.

## Debugging and Diagnostics

### Tracing execution and logging
During development, instrument progs with the `console` statement to emit arbitrary text to the server console and log file—ideal for timing checkpoints or dumping intermediate state while you iterate.【F:MudSharpCore/FutureProg/Statements/ConsoleEcho.cs†L12-L78】 Pair that with the in-game documentation (`prog help statements`, `prog help function <name>`, etc.) to verify syntax and available helpers without leaving the client, which keeps your tracing snippets valid and quickly removable when you are satisfied with the behaviour.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L55-L138】

### Inspecting variables and runtime state
The `prog execute` command lets builders invoke any compiled prog with custom parameters, prints each argument using `DescribeProgVariable`, and reports both the return value and execution time so you can confirm type coercions and outputs interactively.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L715-L769】【F:MudSharpCore/Commands/Modules/ProgModule.cs†L520-L706】 Use `show prog <id>` for a richer snapshot: it highlights whether the prog compiled, lists parameters, surfaces any compile errors, and shows either colourised or raw body text, which is invaluable for cross-checking what the engine is actually running versus what you expect from source control.【F:MudSharpCore/Commands/Modules/ShowModule.cs†L3060-L3145】 Together these tools provide a tight feedback loop for inspecting live variable values without modifying the database.

### Handling and reporting errors
Runtime safeguards in `FutureProg` automatically notify staff via the Discord bridge whenever parameter binding fails, recursion limits are exceeded, a statement returns an error, or an unhandled exception bubbles out, complete with parameter dumps to aid reproduction.【F:MudSharpCore/FutureProg/FutureProg.cs†L529-L637】 On the builder side, editing commands immediately recompile the prog and echo any compiler error back to the editor, while `prog compile` forces a global rebuild and prints the offending progs so you can chase down syntax issues systematically.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L1356-L1409】【F:MudSharpCore/Commands/Modules/ProgModule.cs†L1648-L1662】 Make a habit of addressing those warnings before deployment and leveraging the Discord notifications as actionable tickets rather than silent failures.

## Testing and Validation Workflows

### Unit-style Testing Within FutureMUD
Start by cloning any production prog that you want to experiment with so you can iterate safely. `prog clone <source> [name]` persists a duplicate record—including parameters, metadata, and body text—and immediately opens it in the builder editor, which lets you test against real data without risking the original hook payload.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L1472-L1512】 Once you have a sandbox copy, drive it through `prog execute`. The command coerces each argument to the declared parameter type, prints the resolved values, runs the prog, and reports the typed return plus the elapsed time, giving you a repeatable harness for deterministic checks.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L716-L770】 Argument parsing is identical to what hooks and schedules perform because `GetArgument` enforces the same conversions for collections, reference types, and scalar literals, so the behaviour you see through `prog execute` matches what production callers will experience.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L771-L842】 Pair those executions with `prog show` to confirm the compiled status, signature, comments, and colourised body that the engine currently stores, which is especially useful when you edit text out of band.【F:MudSharpCore/Commands/Modules/ShowModule.cs†L3060-L3112】 For additional observability, sprinkle `console <text>` statements inside the clone—each invocation writes to the server console/log and can be stripped once the behaviour is validated.【F:MudSharpCore/FutureProg/Statements/ConsoleEcho.cs†L13-L99】 Together these tools give you a tight inner loop for unit-style verification entirely inside the running game.

### Regression Testing of Progs
Automate regression checks by scheduling sentinel progs that assert expected world invariants. The `schedule add` workflow only accepts progs with no parameters (or ones flagged as “accepts any”), preventing accidental jobs that require context, and persists the cadence as a `ProgSchedule` tied to the target prog.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L2994-L3058】 Each schedule records the next execution time and lists cleanly via `schedules`, so you can maintain a roster of nightly smoke tests.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L2948-L2971】 At runtime the `ProgSchedule` listener automatically re-queues itself after every run, ensuring your regression suite keeps firing without manual intervention.【F:MudSharpCore/FutureProg/ProgSchedule.cs†L13-L73】 Within those sentinel progs, echo any failures to the console or Discord and rely on register writes to capture counters, mirroring the patterns used in the seeder’s utility scripts. When you need to exercise specific entry points—such as event hooks after a refactor—temporarily attach your test prog through `hook prog`. The command refuses to bind mismatched signatures, so once the hook installs successfully you know the event payload still aligns with your expectations.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L2396-L2466】 Treat these scheduled checks as your automated test suite: they surface regressions quickly and keep long-lived systems honest.

### Checklists Before Deployment
Run through a short checklist every time you ship a change:

1. **Recompile the world.** `prog compile` iterates every stored script, rebuilding caches and surfacing compile errors immediately so you can address syntax issues before builders or hooks trip over them.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L1648-L1670】
2. **Inspect the final artefact.** `prog show <id>` confirms the comment, visibility, parameter list, and colourised text that live in the database, catching mismatched metadata or forgotten edits.【F:MudSharpCore/Commands/Modules/ShowModule.cs†L3060-L3112】
3. **Smoke-test the signature.** Execute the prog with representative inputs and review the duration report before and after your change; if `prog execute` suddenly takes longer, investigate the regressions before release.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L716-L770】
4. **Validate attachments.** Re-run `hook prog` (or `schedule add`) to make sure existing bindings still accept the prog; the commands guard against incompatible parameters, which is a common failure mode after refactoring signatures.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L2396-L2466】【F:MudSharpCore/Commands/Modules/ProgModule.cs†L2994-L3058】

Document the results of this checklist—ideally via console echoes or register updates—so future maintainers can see what was verified before the change went live.

## Best Practices and Patterns

### Coding Standards for FutureProg
Follow the engine’s global style guidance when naming and documenting progs: function names should be descriptive, comments required, and metadata (category, subcategory, public flag) filled in consistently.【F:AGENTS.md†L102-L114】【F:DatabaseSeeder/Seeders/CoreDataSeeder.cs†L2625-L2641】 Within the body, mirror the editor’s formatting rules: FutureProg treats any line starting with `--`, `//`, or `'` as a full-line comment and the colouriser indents by two spaces per nesting level, so write one statement per line, keep indentation shallow, and place comments on their own lines above the code they explain.【F:MudSharpCore/FutureProg/FutureProg.cs†L61-L77】【F:MudSharpCore/FutureProg/FutureProg.cs†L1188-L1247】 Use camel-cased parameter names and include a `FunctionComment` describing intent, mirroring the seed examples, so other builders (or future agents) can understand the contract without digging into callers.【F:DatabaseSeeder/Seeders/CoreDataSeeder.cs†L2625-L2641】 These conventions keep your scripts readable in-game and align with the editor tooling that builders rely on.

### Common Idioms and Anti-patterns
Lean on existing seeds to guide your structure. Utility progs typically start by pulling persisted state with `GetRegister`, normalising it, and writing back with `SetRegister`, as shown in the smoking timer example that resets a timestamp and extends it atomically.【F:DatabaseSeeder/Seeders/UsefulSeeder.cs†L5940-L5959】 Iteration-heavy logic uses `foreach` blocks paired with early `return`s to keep loops concise and avoid hitting guard limits, e.g., the clan-command checks that exit as soon as a qualifying clan appears.【F:DatabaseSeeder/Seeders/UsefulSeeder.cs†L6262-L6293】 On the anti-pattern side, avoid unbounded loops or recursion: the runtime aborts `while` loops after 10,000 iterations and halts progs that recurse more than 250 frames deep, so design your logic with explicit termination conditions and guard clauses to stay well within those ceilings.【F:MudSharpCore/FutureProg/Statements/WhileLoop.cs†L160-L186】【F:MudSharpCore/FutureProg/FutureProg.cs†L527-L563】 Similarly, resist toggling `AcceptsAnyParameters` unless you truly need open-ended signatures—scheduler and hook tooling rely on accurate parameter lists and will refuse to attach progs whose metadata no longer matches their call sites.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L2396-L2466】【F:MudSharpCore/Commands/Modules/ProgModule.cs†L2994-L3043】 Capturing these idioms keeps scripts predictable and prevents the most common runtime faults.

### Performance and Resource Management
Treat long-running progs like production code: profile them and minimise unnecessary work. Because `prog execute` reports elapsed time, keep before-and-after numbers for intensive routines and refactor if you see spikes. Loops already carry safeguards (10,000-iteration cutoff and recursion depth limits), but you should still short-circuit early and cache expensive lookups so you never approach those thresholds.【F:MudSharpCore/FutureProg/Statements/WhileLoop.cs†L160-L190】【F:MudSharpCore/FutureProg/FutureProg.cs†L527-L637】 When a prog is pure and returns the same value every time, mark it fully static—FutureProg caches the first result and skips re-evaluating, which dramatically reduces load on frequently polled checks like permissions.【F:MudSharpCore/FutureProg/FutureProg.cs†L527-L635】【F:DatabaseSeeder/Seeders/CoreDataSeeder.cs†L2625-L2641】 Conversely, unset the static flag whenever a prog starts reading game state so you do not cache stale data. Finally, rely on the scheduler to spread heavy diagnostic runs across in-game time instead of executing everything on demand; the recurring interval infrastructure automatically re-queues work without blocking the main thread.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L2994-L3058】【F:MudSharpCore/FutureProg/ProgSchedule.cs†L13-L73】 Thoughtful throttling keeps the scripting engine responsive even under complex automation.

## Example Library and Case Studies

The DatabaseSeeder project seeds dozens of progs that demonstrate idiomatic use of FutureProg statements, helpers, and metadata. Studying those seeds gives you concrete patterns to adapt when building new automation.

### Annotated Examples From DatabaseSeeder

* **Clan creation gating.** `CanCreateClan` and `OnCreateClan` show how to enforce a persistent eligibility rule. The first prog returns `true` only when a character has accrued at least 1 440 minutes of playtime and their `hascreatedaclan` register flag is still `false`. The companion prog flips that register to `true` once the clan is created, and the seeder defines both the register schema and a default value. Together they illustrate how to combine runtime checks, register persistence, and metadata wiring for static configuration slots.【F:DatabaseSeeder/Seeders/CoreDataSeeder.cs†L2875-L2933】
* **Commandable NPC suites.** The `CommandableOwner` and `CommandableClanOutranks` packages build reusable command-checking logic. Each suite seeds both a permission prog (returning a boolean) and a “why not” prog (returning a message), then embeds the resulting IDs into an `ArtificialIntelligence` definition. `OutranksCanCommand` is a concrete example of looping over a character’s clans, calling `outranks`, and returning early when the condition succeeds. The pattern demonstrates how multiple progs collaborate with AI definitions and why every script needs clear metadata for later lookup.【F:DatabaseSeeder/Seeders/UsefulSeeder.cs†L6245-L6354】
* **Door guard automation.** The Basic Doorguard suite packages the full lifecycle of an automated sentry. It includes gating (`DoorguardWillOpenDoor`), action progs for opening and closing, delay calculators, and fallbacks for rejection or witness handling. The AI definition then stitches those progs together with delay settings and social triggers, providing a ready-made template for any timed interaction that manipulates doors or other room features.【F:DatabaseSeeder/Seeders/UsefulSeeder.cs†L6356-L6646】
* **Aggressive species behaviours.** A minimalist example—`TargetIsOtherRace` feeding into the `AggressiveToAllOtherSpecies` AI—shows how small predicate progs can slot into more complex systems. The boolean helper drives whether an aggressor should attack a given target, while the AI definition specifies delays and emotes. This is a good reference when you need to seed quick behavioural checks without a sprawling body of code.【F:DatabaseSeeder/Seeders/UsefulSeeder.cs†L6648-L6719】

### Reusable Snippets by Category

* **Permission guards.** `IsAdmin` is the canonical template for wrapping sensitive logic: it null-checks the incoming perceivable and delegates to the built-in `IsAdmin` function, returning early when the guard fails. Reuse that structure whenever you need to protect actions behind authority checks or compound it with additional register lookups.【F:DatabaseSeeder/Seeders/CoreDataSeeder.cs†L2851-L2863】
  ```prog
  if (isnull(@ch))
          return false
  end if
  return IsAdmin(@ch)
  ```
* **Register toggles.** `OnCreateClan` is a one-line `setregister` statement. It highlights how to persist new state and makes it obvious why the seeder also adds `VariableDefinition` and `VariableDefault` records—without those, the register would be untyped. Use this pattern to mark milestones that other progs can query.【F:DatabaseSeeder/Seeders/CoreDataSeeder.cs†L2898-L2933】
  ```prog
  setregister @ch "hascreatedaclan" true
  ```
* **Clan loops and early exits.** `OutranksCanCommand` shows a concise `foreach` that inspects a related collection, branches on a helper (`outranks`), and returns immediately when it finds a match. Adopt the same shape when you need to evaluate collections until a condition succeeds and avoid hitting loop guard limits.【F:DatabaseSeeder/Seeders/UsefulSeeder.cs†L6262-L6299】
* **Timed AI actions.** `DoorguardActionDelay` encapsulates a random wait between 40 and 80 ticks. Pairing a simple arithmetic expression with a dedicated prog keeps the delay logic reusable and easy to tune; more complex workflows can exchange the body for collection-aware timing logic while leaving the host AI unchanged.【F:DatabaseSeeder/Seeders/UsefulSeeder.cs†L6392-L6426】
* **Messaging and force commands.** `DoorguardOpenDoor` combines comment annotations, `force` statements, and helper calls such as `bestkeyword` to produce polished output. Use this as a template when you need to script actor emotes, invoke game commands, and leave guidance for future maintainers all in one place.【F:DatabaseSeeder/Seeders/UsefulSeeder.cs†L6463-L6524】

### Patterns for Complex Systems

* **Commandable NPC pattern.** The commandable suites pair eligibility and denial progs with an AI definition that references both IDs. Builders can swap in alternative gating logic (e.g., clan checks or ownership) without editing the AI XML, because the behavioural contract is entirely defined by the seeded progs. This decoupling makes it easy to offer multiple command policies in the same world.【F:DatabaseSeeder/Seeders/UsefulSeeder.cs†L6245-L6354】
* **Door guard orchestration.** The Basic Doorguard AI ties together six progs: a boolean gate, positive and negative responses, open/close actions, a base delay, and an optional witness reaction. Feeding those IDs into the AI definition yields a complete loop—from social triggers to cleanup—while keeping each concern small and testable. You can extend the pattern with extra social hooks or register writes without touching the core logic.【F:DatabaseSeeder/Seeders/UsefulSeeder.cs†L6356-L6646】
* **Aggression triggers.** Simple predicate progs such as `TargetIsOtherRace` can be dropped into larger automation contexts (AI packs, hooks, schedules). Because the behaviour is encapsulated in a boolean, the aggressor AI only needs to reference the prog ID to decide whether to engage, making it trivial to swap in different target-selection rules later.【F:DatabaseSeeder/Seeders/UsefulSeeder.cs†L6648-L6719】

## Reference Appendix

### Statement Reference

| Statement | Behaviour highlights |
| --- | --- |
| `var name as type` | Declares a typed variable, rejects duplicate names or unknown types, and auto-initialises collections/dictionaries with empty containers so later statements can add elements safely.【F:MudSharpCore/FutureProg/Statements/DeclareVariable.cs†L13-L103】 |
| `var name = expression` | Declares and assigns in one line. The compiler infers the declared type from the RHS (stripping the `Literal` flag) and seeds the variable before executing the assignment body so collection defaults are available immediately.【F:MudSharpCore/FutureProg/Statements/DeclareAndAssignVariable.cs†L16-L93】 |
| `name = expression` | Sets an existing variable, enforcing that the RHS return type is compatible with the slot and bubbling up the RHS error message if evaluation fails.【F:MudSharpCore/FutureProg/Statements/SetVariable.cs†L13-L98】 |
| `if` / `elseif` / `else` | Requires boolean expressions for each branch, maintains separate local scopes, and surfaces errors when branches appear out of order or the block lacks a closing `end if`. Returning within any branch stops further evaluation.【F:MudSharpCore/FutureProg/Statements/IfBlock.cs†L43-L169】 |
| `switch` / `case` / `default` | Evaluates the controlling expression once, verifies every `case` returns the same type, and treats `default` as optional but exclusive. A `break` exits the switch, while `return` propagates immediately.【F:MudSharpCore/FutureProg/Statements/Switch.cs†L11-L178】 |
| `while (condition)` | Compiles only boolean conditions, executes with a `LocalVariableSpace`, and aborts after 10 000 iterations to protect the runtime. `break` exits, `continue` restarts the loop, and nested returns bubble upwards.【F:MudSharpCore/FutureProg/Statements/WhileLoop.cs†L13-L190】 |
| `for (var : number)` | Counts from 1 to the supplied number (inclusive), injecting the loop variable into a local scope each iteration. Existing non-number variables trigger a compile error to prevent accidental reuse.【F:MudSharpCore/FutureProg/Statements/ForLoop.cs†L13-L169】 |
| `foreach (var in collection)` | Demands a collection return type, binds each element into a local variable, and supports nested `break`/`continue` semantics identical to other loops.【F:MudSharpCore/FutureProg/Statements/ForEachLoop.cs†L13-L168】 |
| `break` / `continue` | Expected results for loop/switch bodies; emitting them at top level triggers a compile-time rejection in `FutureProg.Compile`. The executors simply return the corresponding `StatementResult` for the parent to interpret.【F:MudSharpCore/FutureProg/Statements/Break.cs†L11-L43】【F:MudSharpCore/FutureProg/Statements/Continue.cs†L11-L42】 |
| `return [expression]` | Without an expression, returns from a void prog. With an expression, the compiler verifies the prog declares a return type and that the expression matches it before allowing compilation.【F:MudSharpCore/FutureProg/Statements/Return.cs†L11-L91】 |
| `delay millis character text` | Queues a command to run later by applying a `DelayedAction` effect to the target character. A zero delay executes immediately, and all three arguments must compile to the correct types.【F:MudSharpCore/FutureProg/Statements/Delay.cs†L13-L146】【F:MudSharpCore/FutureProg/Statements/Delay.cs†L168-L211】 |
| `delayprog progName millis [args…]` | Looks up another prog by name or ID, verifies that the argument list matches one of its signatures, and schedules it via the global scheduler. A zero delay executes the prog inline with the evaluated parameters.【F:MudSharpCore/FutureProg/Statements/DelayProg.cs†L13-L188】 |
| `force character text` | Executes a command as if typed by the specified character, after verifying both parameters compile to the appropriate types. This is the immediate variant of `delay` for NPC automation.【F:MudSharpCore/FutureProg/Statements/Force.cs†L13-L115】 |
| `send [range] [flags] target text [perceivers…]` | Legacy statement for routing emotes or raw text. The compiler enforces range-specific target types and optional perceivers before constructing an `EmoteOutput` at runtime.【F:MudSharpCore/FutureProg/Statements/Send.cs†L15-L243】 |
| `console text` | Evaluates the text expression and writes the result to the server console/log—ideal for diagnostics during testing or scheduled regression runs.【F:MudSharpCore/FutureProg/Statements/ConsoleEcho.cs†L13-L87】 |
| `additem/addrange/removeitem/removeitemindex` | Mutate local collections by adding individual elements, adding another collection, removing a matching element, or removing by zero-based index. All variants validate that the target is a declared collection and the argument types match the element type.【F:MudSharpCore/FutureProg/Statements/AddItem.cs†L13-L122】【F:MudSharpCore/FutureProg/Statements/AddRange.cs†L13-L134】【F:MudSharpCore/FutureProg/Statements/RemoveItem.cs†L13-L118】【F:MudSharpCore/FutureProg/Statements/RemoveItemIndex.cs†L13-L140】 |
| `setregister target "name" value` | Resolves register metadata during compilation, ensuring the register exists for the supplied owner type and that the value expression matches the declared schema before writing to the persistent variable store.【F:MudSharpCore/FutureProg/Statements/SetRegister.cs†L13-L134】 |
| Bare expression | Any line that doesn’t match a statement regex becomes a `FunctionStatement`, so pure function calls can stand alone while still participating in error propagation.【F:MudSharpCore/FutureProg/Statements/FunctionStatement.cs†L1-L19】 |
| `opendoor/closedoor` (manipulation) | Convenience statements for NPC scripting that take a character, an exit, and optional emote text. They check types, resolve optional emotes, and operate on the door component only when the state actually changes.【F:MudSharpCore/FutureProg/Statements/Manipulation/OpenDoor.cs†L15-L148】【F:MudSharpCore/FutureProg/Statements/Manipulation/CloseDoor.cs†L15-L136】 |

### Function Reference by Category

FutureProg functions are registered with `FunctionCompilerInformation`, which stores names, parameter lists, categories, and help text surfaced through `prog help` commands. Each directory under `MudSharpCore/FutureProg/Functions` corresponds to a thematic category.【F:MudSharpCore/FutureProg/Functions/FunctionCompilerInformation.cs†L21-L139】 Use the following high-level map to locate relevant helpers:

| Category | What it covers |
| --- | --- |
| **Built-in helpers** | Type conversion (`tonumber`, `totext`), logical negation, admin checks, and other language-level utilities bundled under `BuiltIn`. These all use the shared compiler infrastructure described above.【F:MudSharpCore/FutureProg/Functions/FunctionCompilerInformation.cs†L21-L139】 |
| **Mathematical** | Arithmetic (`addition`, `subtraction`, `multiplication`), rounding, exponentiation, and modulus operations. Each function enforces numeric parameter types before returning a `NumberVariable`.【F:MudSharpCore/FutureProg/Functions/Mathematical/AdditionFunction.cs†L5-L27】 |
| **Logical** | Short-circuiting boolean combiners like `and`/`or` live under `Logical`, propagating operand errors and returning booleans.【F:MudSharpCore/FutureProg/Functions/Logical/AndFunction.cs†L18-L48】 |
| **Textual** | String manipulation helpers cover concatenation, splitting, substring extraction, and table formatting for builder output.【F:MudSharpCore/FutureProg/Functions/Textual/SplitText.cs†L22-L74】 |
| **Collection extension** | LINQ-style operators (`where`, `select`, `count`, `min`, `max`, `sum`, etc.) that compile inline lambdas against collections. They enforce both the element type and the inner function’s return type.【F:MudSharpCore/FutureProg/Functions/CollectionExtension/WhereFunction.cs†L7-L66】 |
| **Characters** | Character-centric actions such as `giveknowledge`, granting merits, or inspecting stats. Each validates the incoming perceivable and returns success booleans for branching.【F:MudSharpCore/FutureProg/Functions/Characters/GiveKnowledgeFunction.cs†L12-L71】 |
| **Game items** | Item manipulation utilities (e.g., `setlocked`, `setopen`) that understand component interfaces like `ILock`/`ILockable` and return booleans indicating success.【F:MudSharpCore/FutureProg/Functions/GameItem/SetLockedFunction.cs†L8-L60】 |
| **Location and rooms** | Constructors like `createcell`/`createroom` wire new rooms into overlay packages and zones, optionally cloning template rooms. They return locations so follow-up scripts can continue provisioning.【F:MudSharpCore/FutureProg/Functions/Location/CreateCell.cs†L8-L78】 |
| **Currency and economy** | Functions that move currency between rooms, characters, and items (`takecurrency`) plus longer-running economic influences (`begininfluence`). These helpers understand container hierarchies, change-making, and scheduling of market effects.【F:MudSharpCore/FutureProg/Functions/Currency/TakeCurrencyFunction.cs†L200-L320】【F:MudSharpCore/FutureProg/Functions/Economy/BeginInfluence.cs†L19-L104】 |
| **Effects** | Adding or removing effects such as invisibility. They accept perceivables plus optional gating progs and return the effect instance so you can chain additional logic.【F:MudSharpCore/FutureProg/Functions/Effects/AddInvisEffectFunction.cs†L1-L74】 |
| **Discord and integrations** | `senddiscord` lets progs push embeds/messages to configured Discord channels, bridging in-game events with external services.【F:MudSharpCore/FutureProg/Functions/Discord/SendDiscordMessageFunction.cs†L13-L71】 |
| **OpenAI** | `gptrequest` queues GPT interactions, forwarding results to a callback prog for post-processing—useful for AI-driven storytelling or support tooling.【F:MudSharpCore/FutureProg/Functions/OpenAI/GPTRequest.cs†L23-L102】 |
| **Register access** | `getregister` looks up persistent variables by owner and name, returning typed values while honouring register schemas defined in the game world.【F:MudSharpCore/FutureProg/Functions/Register/GetRegisterFunction.cs†L8-L55】 |

### Error Messages and Diagnostics Reference

* **Compilation guards.** The compiler halts when it encounters top-level `break`/`continue`, missing `return` statements for non-void progs, or statement-specific issues such as unknown variable types or non-boolean `if` conditions. Error messages include the failing line number and the specific problem (e.g., “The prog did not end with a return statement” or “If Block’s logic statement returned a non boolean value”).【F:MudSharpCore/FutureProg/FutureProg.cs†L260-L301】【F:MudSharpCore/FutureProg/Statements/DeclareVariable.cs†L24-L68】【F:MudSharpCore/FutureProg/Statements/IfBlock.cs†L43-L90】
* **Type mismatches.** Assignment and return statements verify compatibility using `FutureProgVariableComparer`. When a mismatch occurs, the compiler reports both the expected and actual types, and execution stops before the prog is cached.【F:MudSharpCore/FutureProg/Statements/SetVariable.cs†L24-L69】【F:MudSharpCore/FutureProg/Statements/Return.cs†L27-L70】
* **Loop protection.** Runtime guards abort `while` loops after 10 000 iterations and surface the error “While loop of greater than 10,000 iterations detected, aborting…”, preventing runaway scripts from stalling the engine.【F:MudSharpCore/FutureProg/Statements/WhileLoop.cs†L160-L190】
* **Recursion and execution errors.** `ExecuteWithRecursionProtection` caps recursion at 250 frames and logs parameter-assignment exceptions or runtime errors to Discord for staff review. Any unhandled exception also triggers a Discord notification with the stack trace, keeping administrators informed.【F:MudSharpCore/FutureProg/FutureProg.cs†L537-L618】
* **Function parameter mismatches.** When argument return types do not match a function’s signature, `FunctionCompilerInformation` emits “Function Parameters do not match in … function.”—a hint to check parameter order or coercion rules.【F:MudSharpCore/FutureProg/Functions/FunctionCompilerInformation.cs†L112-L123】

### Glossary of Terms

* **FutureProg.** A compiled script stored with metadata such as category, visibility, parameter list, return type, and static caching mode. Metadata changes trigger recolourisation and mark the prog as dirty until saved.【F:MudSharpCore/FutureProg/FutureProg.cs†L144-L184】
* **Hook.** A link between an engine event and one or more progs. The `FutureProgHook` loader reads XML definitions, resolves prog IDs, and executes each attached prog when the event fires.【F:MudSharpCore/Events/Hooks/FutureProgHook.cs†L12-L78】
* **Variable register.** A persistent key/value store keyed by owner type and variable name. It returns typed defaults (including empty containers) when no value exists and enforces schema compatibility on writes.【F:MudSharpCore/FutureProg/VariableRegister.cs†L760-L820】
* **Effect.** A persistent or scheduled modifier applied to a perceivable. Effects expose lifecycle hooks (`InitialEffect`, `ExpireEffect`, `RemovalEffect`) and can be referenced inside progs via register-style accessors.【F:FutureMUDLibrary/Effects/IEffect.cs†L9-L53】
* **Perceivable.** Any entity that players can perceive—characters, items, rooms—implementing interfaces for descriptions, positions, and effect handling. Many FutureProg functions accept or return perceivables for dot-property access.【F:FutureMUDLibrary/Framework/IPerceivable.cs†L20-L67】
* **Prog schedule.** A persistent scheduler entry that re-queues a parameterless prog according to a `RecurringInterval`, automatically saving its next fire time and re-listening after each execution.【F:MudSharpCore/FutureProg/ProgSchedule.cs†L13-L73】
* **Artificial intelligence definition.** AI XML blocks (seeded in the DatabaseSeeder) reference progs for decisions, delays, and messaging, demonstrating how FutureProg drives complex behaviours without modifying C# code.【F:DatabaseSeeder/Seeders/UsefulSeeder.cs†L6245-L6646】

## Additional Resources and Next Steps

### Tooling and Supporting Projects

* **Futuremud Configuration Tool.** The `FutureProgViewer` control loads progs from the database, recompiles them to surface errors, colourises the body, and exposes editing actions such as cloning, parameter management, and bulk save/load—ideal when you prefer a GUI over in-game editing.【F:Futuremud Configuration Tool/UI/FutureProgViewer.xaml.cs†L25-L116】
* **MudSharp Watcher.** This desktop watcher can launch the server, tail output, and automatically restart when the process exits unexpectedly, giving you a convenient harness for long-running regression progs or automation tests.【F:MudSharp Watcher/ProcessWatcher.cs†L12-L65】
* **Command help inside the MUD.** `prog help` lists statement syntax, function categories, and type information, while `prog execute`, `prog compile`, and metadata subcommands (`prog set …`) provide a disciplined workflow for editing and validating scripts in-game.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L60-L139】
* **Repository scripts.** Use `scripts/setup.sh` once to install the expected .NET SDK locally, and run `scripts/test.sh` to build or smoke-test the engine before or after editing progs outside the live game.【F:AGENTS.md†L191-L196】

### Maintaining and Contributing to the Guide

* Re-run `prog compile` after bulk edits (including offline changes) to refresh every cached script and capture compiler output in one pass.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L1648-L1662】
* Use `prog execute` to document expected inputs and outputs for any example you add to this guide—the command echoes parameters, the typed return value, and the execution duration, which doubles as an informal performance check.【F:MudSharpCore/Commands/Modules/ProgModule.cs†L715-L770】
* When documenting integrations or hooks, cross-reference the actual loader (`FutureProgHook`), scheduler (`ProgSchedule`), or static configuration rows in the seeder so future maintainers can trace the full pipeline from metadata to runtime.【F:MudSharpCore/Events/Hooks/FutureProgHook.cs†L12-L78】【F:MudSharpCore/FutureProg/ProgSchedule.cs†L13-L73】【F:DatabaseSeeder/Seeders/CoreDataSeeder.cs†L2875-L2933】

### Future Learning Opportunities

* **Explore new integrations.** The OpenAI `gptrequest` helper and Discord functions make it possible to blend AI or out-of-game notifications with FutureProg logic. Building tutorials or automated reviewers on top of these APIs would further streamline worldbuilding.【F:MudSharpCore/FutureProg/Functions/OpenAI/GPTRequest.cs†L23-L102】【F:MudSharpCore/FutureProg/Functions/Discord/SendDiscordMessageFunction.cs†L13-L71】
* **Automate reference generation.** Because every built-in registers itself through `FunctionCompilerInformation`, you can script documentation exports directly from that metadata, keeping this guide in sync with code changes over time.【F:MudSharpCore/FutureProg/Functions/FunctionCompilerInformation.cs†L21-L139】
* **Curate extended examples.** Expanding on the seeder patterns—such as wiring door guards into schedules or layering register-driven AI behaviours—will give agents richer templates to draw from and highlight best practices for multi-prog systems.【F:DatabaseSeeder/Seeders/UsefulSeeder.cs†L6356-L6646】
